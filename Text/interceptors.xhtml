<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/javaee-darb.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="ind">
    <a id="GKEED"></a><a id="JEETT00113"></a>

    <h1 class="chapter"><span class="secnum">54</span> <a id="sthref2912"></a><a id="sthref2913"></a>Using Java EE Interceptors</h1>

    <p>This chapter discusses how to create interceptor classes and methods that interpose on method invocations or lifecycle events on a target class.</p>

    <p>The following topics are addressed here:</p>

    <ul>
      <li>
        <p><a href="../Text/interceptors.xhtml#GKIGQ">Overview of Interceptors</a></p>
      </li>

      <li>
        <p><a href="../Text/interceptors.xhtml#GKEDM">Using Interceptors</a></p>
      </li>

      <li>
        <p><a href="../Text/interceptors.xhtml#GKECI">The interceptor Example Application</a></p>
      </li>
    </ul>
  </div>

  <div class="ind">
    <a id="GKIGQ"></a><a id="JEETT00563"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">54.1</span> Overview of Interceptors</h1>

      <p>Interceptors are used in conjunction with Java EE managed classes to allow developers to invoke interceptor methods on an associated <span class="glossaryterm">target class</span>, in conjunction with method invocations or lifecycle events. Common uses of interceptors are logging, auditing, and profiling.</p>

      <p>Although interceptors are part of Enterprise JavaBeans 3.2 and Contexts and Dependency Injection for Java EE 1.1, the Interceptors 1.2 specification is downloadable as part of a maintenance release of JSR 318, Enterprise JavaBeans 3.1, available from <code><a href="../Text/interceptors.xhtml#http%3A//jcp.org/en/jsr/detail%3Fid%3D318">http://jcp.org/en/jsr/detail?id=318</a></code>. You can use interceptors with session beans, message-driven beans, and CDI managed beans. In all of these cases, the interceptor target class is the bean class.</p>

      <p>An interceptor can be defined within a target class as an <span class="glossaryterm">interceptor method</span>, or in an associated class called an <span class="glossaryterm">interceptor class</span>. Interceptor classes contain methods that are invoked in conjunction with the methods or lifecycle events of the target class.</p>

      <p>Interceptor classes and methods are defined using metadata annotations, or in the deployment descriptor of the application that contains the interceptors and target classes.</p>

      <div align="center">
        <div class="inftblnote">
          <br />

          <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
            <tbody>
              <tr>
                <td align="left">
                  <p class="notep1">Note:</p>

                  <p>Applications that use the deployment descriptor to define interceptors are not portable across Java EE servers.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>
      </div>

      <p><a id="sthref2914"></a>Interceptor methods within the target class or in an interceptor class are annotated with one of the metadata annotations defined in <a href="../Text/interceptors.xhtml#GKECC">Table 54-1</a>.</p>

      <div class="tblhruleformal">
        <a id="sthref2915"></a><a id="GKECC"></a>

        <p class="titleintable">Table 54-1 Interceptor Metadata Annotations</p>

        <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and describes the interceptor metadata annotations." title="Interceptor Metadata Annotations" width="100%">
          <col width="44%" />
          <col width="*" />

          <thead>
            <tr align="left" valign="top">
              <th align="left" id="r1c1-t3" valign="bottom">Interceptor Metadata Annotation</th>

              <th align="left" id="r1c2-t3" valign="bottom">Description</th>
            </tr>
          </thead>

          <tbody>
            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t3" id="r2c1-t3">
                <p><code>javax.interceptor.AroundConstruct</code></p>
              </td>

              <td align="left" headers="r2c1-t3 r1c2-t3">
                <p>Designates the method as an interceptor method that receives a callback after the target class is constructed</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t3" id="r3c1-t3">
                <p><a id="sthref2916"></a><code>javax.interceptor.AroundInvoke</code></p>
              </td>

              <td align="left" headers="r3c1-t3 r1c2-t3">
                <p>Designates the method as an interceptor method</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t3" id="r4c1-t3">
                <p><a id="sthref2917"></a><code>javax.interceptor.AroundTimeout</code></p>
              </td>

              <td align="left" headers="r4c1-t3 r1c2-t3">
                <p>Designates the method as a timeout interceptor for interposing on timeout methods for enterprise bean timers</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t3" id="r5c1-t3">
                <p><a id="sthref2918"></a><code>javax.annotation.PostConstruct</code></p>
              </td>

              <td align="left" headers="r5c1-t3 r1c2-t3">
                <p>Designates the method as an interceptor method for post-construct lifecycle events</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t3" id="r6c1-t3">
                <p><a id="sthref2919"></a><code>javax.annotation.PreDestroy</code></p>
              </td>

              <td align="left" headers="r6c1-t3 r1c2-t3">
                <p>Designates the method as an interceptor method for pre-destroy lifecycle events</p>
              </td>
            </tr>
          </tbody>
        </table><br />
      </div><a id="GKECK"></a><a id="JEETT01314"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.1.1</span> Interceptor Classes</h2>

        <p><a id="sthref2920"></a>Interceptor classes may be designated with the optional <code>javax.interceptor.Interceptor</code> annotation, but interceptor classes are not required to be so annotated. An interceptor class <span class="italic">must</span> have a public, no-argument constructor.</p>

        <p><a id="sthref2921"></a>The target class can have any number of interceptor classes associated with it. The order in which the interceptor classes are invoked is determined by the order in which the interceptor classes are defined in the <code>javax.interceptor.Interceptors</code> annotation. However, this order can be overridden in the deployment descriptor.</p>

        <p>Interceptor classes may be targets of dependency injection. Dependency injection occurs when the interceptor class instance is created, using the naming context of the associated target class, and before any <code>@PostConstruct</code> callbacks are invoked.</p>
      </div><a id="GKEDY"></a><a id="JEETT01315"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.1.2</span> Interceptor Lifecycle</h2>

        <p>Interceptor classes have the same lifecycle as their associated target class. When a target class instance is created, an interceptor class instance is also created for each declared interceptor class in the target class. That is, if the target class declares multiple interceptor classes, an instance of each class is created when the target class instance is created. The target class instance and all interceptor class instances are fully instantiated before any <code>@PostConstruct</code> callbacks are invoked, and any <code>@PreDestroy</code> callbacks are invoked before the target class and interceptor class instances are destroyed.</p>
      </div><a id="GKHSN"></a><a id="JEETT01316"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.1.3</span> Interceptors and CDI</h2>

        <p>Contexts and Dependency Injection for Java EE (CDI) builds on the basic functionality of Java EE interceptors. For information on CDI interceptors, including a discussion of interceptor binding types, see <a href="../Text/cdi-adv.xhtml#GKHJX">Using Interceptors in CDI Applications</a>.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GKEDM"></a><a id="JEETT00564"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">54.2</span> Using Interceptors</h1>

      <p>To define an interceptor, use one of the interceptor metadata annotations listed in <a href="../Text/interceptors.xhtml#GKECC">Table 54-1</a> within the target class, or in a separate interceptor class. The following code declares an <code>@AroundTimeout</code> interceptor method within a target class:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Stateless
public class TimerBean {
    ...
    @Schedule(minute="*/1", hour="*")
    public void automaticTimerMethod() { ... }

    @AroundTimeout
    public void timeoutInterceptorMethod(InvocationContext ctx) { ... }
    ...
}</pre>

      <p>If you are using interceptor classes, use the <code>javax.interceptor.Interceptors</code> annotation to declare one or more interceptors at the class or method level of the target class. The following code declares interceptors at the class level:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Stateless
@Interceptors({PrimaryInterceptor.class, SecondaryInterceptor.class})
public class OrderBean { ... }</pre>

      <p>The following code declares a method-level interceptor class:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Stateless
public class OrderBean {
    ...
    @Interceptors(OrderInterceptor.class)
    public void placeOrder(Order order) { ... }
    ...
}</pre><a id="GKECY"></a><a id="JEETT01317"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.2.1</span> <a id="sthref2922"></a>Intercepting Method Invocations</h2>

        <p>Use the <code>@AroundInvoke</code> annotation to designate interceptor methods for managed object methods. Only one around-invoke interceptor method per class is allowed. Around-invoke interceptor methods have the following form:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@AroundInvoke
visibility Object method-name(InvocationContext) throws Exception { ... }<br /></pre>

        <p>For example:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@AroundInvoke
public void interceptOrder(InvocationContext ctx) { ... }</pre>

        <p>Around-invoke interceptor methods can have public, private, protected, or package-level access, and must not be declared static or final.</p>

        <p>An around-invoke interceptor can call any component or resource that is callable by the target method on which it interposes, can have the same security and transaction context as the target method, and can run in the same Java virtual machine call stack as the target method.</p>

        <p>Around-invoke interceptors can throw runtime exceptions and any exception allowed by the <code>throws</code> clause of the target method. They may catch and suppress exceptions, and then recover by calling the <code>InvocationContext.proceed</code> method.</p><a id="GKHMH"></a><a id="JEETT00838"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.2.1.1</span> Using Multiple Method Interceptors</h3>

          <p>Use the <code>@Interceptors</code> annotation to declare multiple interceptors for a target method or class:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptors({PrimaryInterceptor.class, SecondaryInterceptor.class, 
        LastInterceptor.class})
public void updateInfo(String info) { ... }</pre>

          <p>The order of the interceptors in the <code>@Interceptors</code> annotation is the order in which the interceptors are invoked.</p>

          <p>You can also define multiple interceptors in the deployment descriptor. The order of the interceptors in the deployment descriptor is the order in which the interceptors will be invoked:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">...
&lt;interceptor-binding&gt;
    &lt;target-name&gt;myapp.OrderBean&lt;/target-name&gt;
    &lt;interceptor-class&gt;myapp.PrimaryInterceptor.class&lt;/interceptor-class&gt;
    &lt;interceptor-class&gt;myapp.SecondaryInterceptor.class&lt;/interceptor-class&gt;
    &lt;interceptor-class&gt;myapp.LastInterceptor.class&lt;/interceptor-class&gt;
    &lt;method-name&gt;updateInfo&lt;/method-name&gt;
&lt;/interceptor-binding&gt;
...</pre>

          <p>To explicitly pass control to the next interceptor in the chain, call the <code>InvocationContext.proceed</code> method.</p>

          <p>Data can be shared across interceptors.</p>

          <ul>
            <li>
              <p>The same <code>InvocationContext</code> instance is passed as an input parameter to each interceptor method in the interceptor chain for a particular target method. The <code>InvocationContext</code> instance's <code>contextData</code> property is used to pass data across interceptor methods. The <code>contextData</code> property is a <code>java.util.MapString, Object</code> object. Data stored in <code>contextData</code> is accessible to interceptor methods further down the interceptor chain.</p>
            </li>

            <li>
              <p>The data stored in <code>contextData</code> is not sharable across separate target class method invocations. That is, a different <code>InvocationContext</code> object is created for each invocation of the method in the target class.</p>
            </li>
          </ul>
        </div><a id="GKHOV"></a><a id="JEETT00839"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.2.1.2</span> Accessing Target Method Parameters from an Interceptor Class</h3>

          <p>You can use the <code>InvocationContext</code> instance passed to each around-invoke method to access and modify the parameters of the target method. The <code>parameters</code> property of <code>InvocationContext</code> is an array of <code>Object</code> instances that corresponds to the parameter order of the target method. For example, for the following target method, the <code>parameters</code> property, in the <code>InvocationContext</code> instance passed to the around-invoke interceptor method in <code>PrimaryInterceptor</code>, is an <code>Object</code> array containing two <code>String</code> objects (<code>firstName</code> and <code>lastName</code>) and a <code>Date</code> object (<code>date</code>):</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptors(PrimaryInterceptor.class)
public void updateInfo(String firstName, String lastName, Date date) { ... }</pre>

          <p>You can access and modify the parameters by using the <code>InvocationContext.getParameters</code> and <code>InvocationContext.setParameters</code> methods, respectively.</p>
        </div>
      </div><a id="GKECR"></a><a id="JEETT01318"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.2.2</span> <a id="sthref2923"></a><a id="sthref2924"></a><a id="sthref2925"></a>Intercepting Lifecycle Callback Events</h2>

        <p>Interceptors for lifecycle callback events (around-construct, post-construct, and pre-destroy) may be defined in the target class or in interceptor classes. The <code>javax.interceptor.AroundConstruct</code> annotation designates the method as an interceptor method that interposes on the invocation of the target class's constructor. The <code>javax.annotation.PostConstruct</code> annotation is used to designate a method as a post-construct lifecycle event interceptor. The <code>javax.annotation.PreDestroy</code> annotation is used to designate a method as a pre-destroy lifecycle event interceptor.</p>

        <p>Lifecycle event interceptors defined within the target class have the following form:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">void <span class="variable">method-name</span>() { ... }</pre>

        <p>For example:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PostConstruct
void initialize() { ... }</pre>

        <p>Lifecycle event interceptors defined in an interceptor class have the following form:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">void <span class="variable">method-name</span>(InvocationContext) { ... }</pre>

        <p>For example:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PreDestroy
void cleanup(InvocationContext ctx) { ... }</pre>

        <p>Lifecycle interceptor methods can have public, private, protected, or package-level access, and must not be declared static or final. Lifecycle interceptors may throw runtime exceptions but cannot throw checked exceptions.</p>

        <p>Lifecycle interceptor methods are called in an unspecified security and transaction context. That is, portable Java EE applications should not assume the lifecycle event interceptor method has access to a security or transaction context. Only one interceptor method for each lifecycle event (post-create and pre-destroy) is allowed per class.</p>

        <div class="sect3">
          <a id="sthref2926"></a>

          <h3 class="sect3"><span class="secnum">54.2.2.1</span> Using AroundConstruct Interceptor Methods</h3>

          <p><code>@AroundConstruct</code> methods are interposed on the invocation of the target class's constructor. Methods decorated with <code>@AroundConstruct</code> may only be defined within interceptor classes or superclasses of interceptor classes. You may not use <code>@AroundConstruct</code> methods within the target class.</p>

          <p>The <code>@AroundConstruct</code> method is called after dependency injection has been completed for all interceptors associated with the target class. The target class is created and the target class's constructor injection is performed after all associated <code>@AroundConstruct</code> methods have called the <code>Invocation.proceed</code> method. At that point, dependency injection for the target class is completed, and then any <code>@PostConstruct</code> callback methods are invoked.</p>

          <p><code>@AroundConstruct</code> methods can access the constructed target instance after calling <code>Invocation.proceed</code> by calling the <code>InvocationContext.getTarget</code> method.</p>

          <div align="center">
            <div class="inftblnote">
              <br />

              <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
                <tbody>
                  <tr>
                    <td align="left">
                      <p class="notep1">Caution:</p>

                      <p>Calling methods on the target instance from an <code>@AroundConstruct</code> method is dangerous because dependency injection may not have completed on the target instance.</p>
                    </td>
                  </tr>
                </tbody>
              </table><br />
            </div>
          </div>

          <p><code>@AroundConstruct</code> methods must call <code>Invocation.proceed</code> in order to create the target instance. If an <code>@AroundConstruct</code> method does not call <code>Invocation.proceed</code>, the target instance will not be created.</p>
        </div><a id="GKHNI"></a><a id="JEETT00840"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.2.2.2</span> Using Multiple Lifecycle Callback Interceptors</h3>

          <p>You can define multiple lifecycle interceptors for a target class by specifying the interceptor classes in the <code>@Interceptors</code> annotation:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptors({PrimaryInterceptor.class, SecondaryInterceptor.class, 
        LastInterceptor.class})
@Stateless
public class OrderBean { ... }</pre>

          <p>Data stored in the <code>contextData</code> property of <code>InvocationContext</code> is not sharable across different lifecycle events.</p>
        </div>
      </div><a id="GKEDU"></a><a id="JEETT01319"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">54.2.3</span> Intercepting Timeout Events</h2>

        <p>You can define interceptors for EJB timer service timeout methods by using the <code>@AroundTimeout</code> annotation on methods in the target class or in an interceptor class. Only one <code>@AroundTimeout</code> method per class is allowed.</p>

        <p>Timeout interceptors have the following form:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">Object <span class="variable">method-name</span>(InvocationContext) throws Exception { ... }</pre>

        <p>For example:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@AroundTimeout
protected void timeoutInterceptorMethod(InvocationContext ctx) { ... }</pre>

        <p>Timeout interceptor methods can have public, private, protected, or package-level access, and must not be declared static or final.</p>

        <p>Timeout interceptors can call any component or resource callable by the target timeout method, and are invoked in the same transaction and security context as the target method.</p>

        <p>Timeout interceptors may access the timer object associated with the target timeout method through the <code>InvocationContext</code> instance's <code>getTimer</code> method.</p><a id="GKHLA"></a><a id="JEETT00841"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.2.3.1</span> Using Multiple Timeout Interceptors</h3>

          <p>You can define multiple timeout interceptors for a given target class by specifying the interceptor classes containing <code>@AroundTimeout</code> interceptor methods in an <code>@Interceptors</code> annotation at the class level.</p>

          <p>If a target class specifies timeout interceptors in an interceptor class, and also has an <code>@AroundTimeout</code> interceptor method within the target class itself, the timeout interceptors in the interceptor classes are called first, followed by the timeout interceptors defined in the target class. For example, in the following example, assume that both the <code>PrimaryInterceptor</code> and <code>SecondaryInterceptor</code> classes have timeout interceptor methods:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptors({PrimaryInterceptor.class, SecondaryInterceptor.class})
@Stateful
public class OrderBean {
    ...
    @AroundTimeout
    private void last(InvocationContext ctx) { ... }
    ...
}</pre>

          <p>The timeout interceptor in <code>PrimaryInterceptor</code> will be called first, followed by the timeout interceptor in <code>SecondaryInterceptor</code>, and finally the <code>last</code> method defined in the target class.</p>
        </div>
      </div>

      <div class="sect2">
        <a id="sthref2927"></a>

        <h2 class="sect2"><span class="secnum">54.2.4</span> Binding Interceptors to Components</h2>

        <p>Interceptor binding types are annotations that may be applied to components to associate them with a particular interceptor. Interceptor binding types are typically custom runtime annotation types that specify the interceptor target. Use the <code>javax.interceptor.InterceptorBinding</code> annotation on the custom annotation definition and specify the target by using <code>@Target</code>, setting one or more of <code>TYPE</code> (class-level interceptors), <code>METHOD</code> (method-level interceptors), <code>CONSTRUCTOR</code> (around-construct interceptors), or any other valid target:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
@Inherited
pubic @interface Logged { ... }</pre>

        <p>Interceptor binding types may also be applied to other interceptor binding types:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Logged
@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
@Inherited
public @interface Secured { ... }</pre>

        <div class="sect3">
          <a id="sthref2928"></a>

          <h3 class="sect3"><span class="secnum">54.2.4.1</span> Declaring the Interceptor Bindings on an Interceptor Class</h3>

          <p>Annotate the interceptor class with the interceptor binding type and <code>@Interceptor</code> to associate the interceptor binding with the interceptor class:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Logged
@Interceptor
public class LoggingInterceptor {
    @AroundInvoke
    public Object logInvocation(InvocationContext ctx) throws Exception { ... }
    ...
}</pre>

          <p>An interceptor class may declare multiple interceptor binding types, and more than one interceptor class may declare an interceptor binding type.</p>

          <p>If the interceptor class intercepts lifecycle callbacks, it can only declare interceptor binding types with <code>Target(TYPE)</code>, or in the case of <code>@AroundConstruct</code> lifecycle callbacks, <code>Target(CONSTRUCTOR)</code>.</p>
        </div>

        <div class="sect3">
          <a id="sthref2929"></a>

          <h3 class="sect3"><span class="secnum">54.2.4.2</span> Binding a Component to an Interceptor</h3>

          <p>Add the interceptor binding type annotation to the target component's class, method, or constructor. Interceptor binding types are applied using the same rules as <code>@Interceptor</code> annotations:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Logged
public class Message {
    ...
    @Secured
    public void getConfidentialMessage() { ... }
    ...
}</pre>

          <p>If the component has a class-level interceptor binding, it must not be <code>final</code> or have any non-<code>static</code>, non-<code>private</code> <code>final</code> methods. If a non-<code>static</code>, non-<code>private</code> method has an interceptor binding applied to it, it must not be <code>final</code>, and the component class cannot be <code>final</code>.</p>
        </div>
      </div>

      <div class="sect2">
        <a id="sthref2930"></a>

        <h2 class="sect2"><span class="secnum">54.2.5</span> <a id="sthref2931"></a><a id="sthref2932"></a>Ordering Interceptors</h2>

        <p>The order in which multiple interceptors are invoked is determined by the following rules.</p>

        <ul>
          <li>
            <p>Default interceptors are defined in a deployment descriptor, and are invoked first. They may specify the invocation order or override the order specified using annotations. Default interceptors are invoked in the order in which they are defined in the deployment descriptor.</p>
          </li>

          <li>
            <p>The order in which the interceptor classes are listed in the <code>@Interceptors</code> annotation defines the order in which the interceptors are invoked. Any <code>@Priority</code> settings for interceptors listed within an <code>@Interceptors</code> annotation are ignored.</p>
          </li>

          <li>
            <p>If the interceptor class has superclasses, the interceptors defined on the superclasses are invoked first, starting with the most general superclass.</p>
          </li>

          <li>
            <p>Interceptor classes may set the priority of the interceptor methods by setting a value within a <code>javax.annotation.Priority</code> annotation.</p>
          </li>

          <li>
            <p>After the interceptors defined within interceptor classes have been invoked, the target class's constructor, around-invoke, or around-timeout interceptors are invoked in the same order as the interceptors within the <code>@Interceptors</code> annotation.</p>
          </li>

          <li>
            <p>If the target class has superclasses, any interceptors defined on the superclasses are invoked first, starting with the most general superclass.</p>
          </li>
        </ul>

        <p>The <code>@Priority</code> annotation requires an <code>int</code> value as an element. The lower the number, the higher the priority of the associated interceptor.</p>

        <div align="center">
          <div class="inftblnote">
            <br />

            <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
              <tbody>
                <tr>
                  <td align="left">
                    <p class="notep1">Note:</p>

                    <p>The invocation order of interceptors with the same priority value is implementation-specific.</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div>

        <p>The <code>javax.interceptor.Interceptor.Priority</code> class defines the priority constants listed in <a href="../Text/interceptors.xhtml#BABFBAEF">Table 54-2</a>.</p>

        <div class="tblformal">
          <a id="sthref2933"></a><a id="BABFBAEF"></a>

          <p class="titleintable">Table 54-2 Interceptor Priority Constants</p>

          <table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="Description of Interceptor.Priority constants." title="Interceptor Priority Constants" width="100%">
            <col width="26%" />
            <col width="13%" />
            <col width="*" />

            <thead>
              <tr align="left" valign="top">
                <th align="left" id="r1c1-t6" valign="bottom">Priority Constant</th>

                <th align="left" id="r1c2-t6" valign="bottom">Value</th>

                <th align="left" id="r1c3-t6" valign="bottom">Description</th>
              </tr>
            </thead>

            <tbody>
              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r2c1-t6">
                  <p><code>PLATFORM_BEFORE</code></p>
                </td>

                <td align="left" headers="r2c1-t6 r1c2-t6">
                  <p>0</p>
                </td>

                <td align="left" headers="r2c1-t6 r1c3-t6">
                  <p>Interceptors defined by the Java EE Platform and intended to be invoked early in the invocation chain should use the range between <code>PLATFORM_BEFORE</code> and <code>LIBRARY_BEFORE</code>. These interceptors have the highest priority.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r3c1-t6">
                  <p><code>LIBRARY_BEFORE</code></p>
                </td>

                <td align="left" headers="r3c1-t6 r1c2-t6">
                  <p>1000</p>
                </td>

                <td align="left" headers="r3c1-t6 r1c3-t6">
                  <p>Interceptors defined by extension libraries that should be invoked early in the interceptor chain should use the range between <code>LIBRARY_BEFORE</code> and <code>APPLICATION</code>.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r4c1-t6">
                  <p><code>APPLICATION</code></p>
                </td>

                <td align="left" headers="r4c1-t6 r1c2-t6">
                  <p>2000</p>
                </td>

                <td align="left" headers="r4c1-t6 r1c3-t6">
                  <p>Interceptors defined by applications should use the range between <code>APPLICATION</code> and <code>LIBRARY_AFTER</code>.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r5c1-t6">
                  <p><code>LIBRARY_AFTER</code></p>
                </td>

                <td align="left" headers="r5c1-t6 r1c2-t6">
                  <p>3000</p>
                </td>

                <td align="left" headers="r5c1-t6 r1c3-t6">
                  <p>Low priority interceptors defined by extension libraries should use the range between <code>LIBRARY_AFTER</code> and <code>PLATFORM_AFTER</code>.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r6c1-t6">
                  <p><code>PLATFORM_AFTER</code></p>
                </td>

                <td align="left" headers="r6c1-t6 r1c2-t6">
                  <p>4000</p>
                </td>

                <td align="left" headers="r6c1-t6 r1c3-t6">
                  <p>Low priority interceptors defined by the Java EE Platform should have values higher than <code>PLATFORM_AFTER</code>.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>

        <div align="center">
          <div class="inftblnote">
            <br />

            <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
              <tbody>
                <tr>
                  <td align="left">
                    <p class="notep1">Note:</p>

                    <p>Negative priority values are reserved by the Interceptors specification for future use, and should not be used.</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div>

        <p>The following code snippet shows how to use the priority constants in an application-defined interceptor:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptor
@Priority(Interceptor.Priority.APPLICATION+200
public class MyInterceptor { ... }</pre>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GKECI"></a><a id="JEETT00565"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">54.3</span> <a id="sthref2934"></a><a id="sthref2935"></a><a id="sthref2936"></a>The interceptor Example Application</h1>

      <p>The <code>interceptor</code> example demonstrates how to use an interceptor class, containing an <code>@AroundInvoke</code> interceptor method, with a stateless session bean.</p>

      <p>The <code>HelloBean</code> stateless session bean is a simple enterprise bean with two business methods, <code>getName</code> and <code>setName</code>, to retrieve and modify a string. The <code>setName</code> business method has an <code>@Interceptors</code> annotation that specifies an interceptor class, <code>HelloInterceptor</code>, for that method:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Interceptors(HelloInterceptor.class)
public void setName(String name) {
    this.name = name;
}</pre>

      <p>The <code>HelloInterceptor</code> class defines an <code>@AroundInvoke</code> interceptor method, <code>modifyGreeting</code>, that converts the string passed to <code>HelloBean.setName</code> to lowercase:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@AroundInvoke
public Object modifyGreeting(InvocationContext ctx) throws Exception {
    Object[] parameters = ctx.getParameters();
    String param = (String) parameters[0];
    param = param.toLowerCase();
    parameters[0] = param;
    ctx.setParameters(parameters);
    try {
        return ctx.proceed();
    } catch (Exception e) {
        logger.warning("Error calling ctx.proceed in modifyGreeting()");
        return null;
    }
}</pre>

      <p>The parameters to <code>HelloBean.setName</code> are retrieved and stored in an <code>Object</code> array by calling the <code>InvocationContext.getParameters</code> method. Because <code>setName</code> only has one parameter, it is the first and only element in the array. The string is set to lowercase and stored in the <code>parameters</code> array, then passed to <code>InvocationContext.setParameters</code>. To return control to the session bean, <code>InvocationContext.proceed</code> is called.</p>

      <p>The user interface of <code>interceptor</code> is a JavaServer Faces web application that consists of two Facelets views: <code>index.xhtml</code>, which contains a form for entering the name, and <code>response.xhtml</code>, which displays the final name.</p>

      <div class="sect2">
        <a id="sthref2937"></a>

        <h2 class="sect2"><span class="secnum">54.3.1</span> Running the interceptor Example</h2>

        <p>You can use either NetBeans IDE or Maven to build, package, deploy, and run the <code>interceptor</code> example.</p><a id="GKEDF"></a><a id="JEETT00292"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.3.1.1</span> To Run the interceptor Example Using NetBeans IDE</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>From the <span class="gui-object-action">File</span> menu, choose <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-title">Open Project</span> dialog box, navigate to:</p>
              <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace"><span class="variable">tut-install</span>/examples/ejb</pre>
            </li>

            <li>
              <p>Select the <code>interceptor</code> folder and click <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-action">Projects</span> tab, right-click the <code>interceptor</code> project and select <span class="gui-object-action">Run</span>.</p>

              <p>This will compile, deploy, and run the <code>interceptor</code> example, opening a web browser to the following URL:</p>
              <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">http://localhost:8080/interceptor/</pre>
            </li>

            <li>
              <p>Enter a name into the form and click <span class="gui-object-action">Submit</span>.</p>

              <p>The name will be converted to lowercase by the method interceptor defined in the <code>HelloInterceptor</code> class.</p>
            </li>
          </ol>
        </div><a id="GKECT"></a><a id="JEETT00293"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">54.3.1.2</span> To Run the interceptor Example Using Maven</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>Go to the following directory:</p>
              <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace"><span class="variable">tut-install</span>/examples/ejb/interceptor/</pre>
            </li>

            <li>
              <p>To compile the source files and package the application, use the following command:</p>
              <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">mvn install</pre>

              <p>This command builds and packages the application into a WAR file, <code>interceptor.war</code>, located in the <code>target</code> directory. The WAR file is then deployed to GlassFish Server.</p>
            </li>

            <li>
              <p>Open the following URL in a web browser:</p>
              <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">http://localhost:8080/interceptor/</pre>
            </li>

            <li>
              <p>Enter a name into the form and click <span class="gui-object-action">Submit</span>.</p>

              <p>The name will be converted to lowercase by the method interceptor defined in the <code>HelloInterceptor</code> class.</p>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
