<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/javaee-darb.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="ind">
    <a id="BNAAW"></a><a id="JEETT00064"></a>

    <h1 class="chapter"><span class="secnum">1</span> <a id="sthref2"></a>Overview</h1>

    <p>This chapter introduces you to Java EE enterprise application development. Here you will review development basics, learn about the Java EE architecture and APIs, become acquainted with important terms and concepts, and find out how to approach Java EE application programming, assembly, and deployment.</p>

    <p><a id="sthref3"></a>Developers today increasingly recognize the need for distributed, transactional, and portable applications that leverage the speed, security, and reliability of server-side technology. <span class="glossaryterm">Enterprise applications</span> provide the business logic for an enterprise. They are centrally managed and often interact with other enterprise software. In the world of information technology, enterprise applications must be designed, built, and produced for less money, with greater speed, and with fewer resources.</p>

    <p>With the Java Platform, Enterprise Edition (Java EE), development of Java enterprise applications has never been easier or faster. The aim of the Java EE platform is to provide developers with a powerful set of APIs while shortening development time, reducing application complexity, and improving application performance.</p>

    <p>The Java EE platform is developed through the Java Community Process (JCP), which is responsible for all Java technologies. Expert groups composed of interested parties have created Java Specification Requests (JSRs) to define the various Java EE technologies. The work of the Java Community under the JCP program helps to ensure Java technology's standards of stability and cross-platform compatibility.</p>

    <p><a id="sthref4"></a>The Java EE platform uses a simplified programming model. XML deployment descriptors are optional. Instead, a developer can simply enter the information as an <span class="glossaryterm">annotation</span> directly into a Java source file, and the Java EE server will configure the component at deployment and runtime. These annotations are generally used to embed in a program data that would otherwise be furnished in a deployment descriptor. With annotations, you put the specification information in your code next to the program element affected.</p>

    <p>In the Java EE platform, dependency injection can be applied to all resources a component needs, effectively hiding the creation and lookup of resources from application code. Dependency injection can be used in Enterprise JavaBeans (EJB) containers, web containers, and application clients. Dependency injection allows the Java EE container to automatically insert references to other required components or resources, using annotations.</p>

    <p>This tutorial uses examples to describe the features available in the Java EE platform for developing enterprise applications. Whether you are a new or experienced enterprise developer, you should find the examples and accompanying text a valuable and accessible knowledge base for creating your own solutions.</p>

    <p>The following topics are addressed here:</p>

    <ul>
      <li>
        <p><a href="../Text/overview.xhtml#GIQVH">Java EE 7 Platform Highlights</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNAAX">Java EE Application Model</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNAAY">Distributed Multitiered Applications</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNABO">Java EE Containers</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNABS">Web Services Support</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNABX">Java EE Application Assembly and Deployment</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNACJ">Java EE 7 APIs</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#GIRDR">Java EE 7 APIs in the Java Platform, Standard Edition 7</a></p>
      </li>

      <li>
        <p><a href="../Text/overview.xhtml#BNADF">GlassFish Server Tools</a></p>
      </li>
    </ul>
  </div>

  <div class="ind">
    <a id="GIQVH"></a><a id="JEETT00306"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.1</span> Java EE 7 Platform Highlights</h1>

      <p><a id="sthref5"></a>The most important goal of the Java EE 7 platform is to simplify development by providing a common foundation for the various kinds of components in the Java EE platform. Developers benefit from productivity improvements with more annotations and less XML configuration, more Plain Old Java Objects (POJOs), and simplified packaging. The Java EE 7 platform includes the following new features:</p>

      <ul>
        <li>
          <p>New technologies, including the following:</p>

          <ul>
            <li>
              <p><a href="../Text/overview.xhtml#CJAJHGIH">Batch Applications for the Java Platform</a></p>
            </li>

            <li>
              <p><a href="../Text/overview.xhtml#CJAFGFCJ">Concurrency Utilities for Java EE</a></p>
            </li>

            <li>
              <p><a href="../Text/overview.xhtml#CJAGIEEI">Java API for JSON Processing</a> (JSON-P)</p>
            </li>

            <li>
              <p><a href="../Text/overview.xhtml#CJAHDJBJ">Java API for WebSocket</a></p>
            </li>
          </ul>
        </li>

        <li>
          <p>New features for EJB components (see <a href="../Text/overview.xhtml#BNACL">Enterprise JavaBeans Technology</a> for details)</p>
        </li>

        <li>
          <p>New features for servlets (see <a href="../Text/overview.xhtml#BNACM">Java Servlet Technology</a> for details)</p>
        </li>

        <li>
          <p>New features for JavaServer Faces components (see <a href="../Text/overview.xhtml#BNACP">JavaServer Faces Technology</a> for details)</p>
        </li>

        <li>
          <p>New features for the Java Message Service (JMS) (see <a href="../Text/overview.xhtml#BNACQ">Java Message Service API</a> for details)</p>
        </li>
      </ul>
    </div>
  </div>

  <div class="ind">
    <a id="BNAAX"></a><a id="JEETT00307"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.2</span> Java EE Application Model</h1>

      <p>The Java EE application model begins with the Java programming language and the Java virtual machine. The proven portability, security, and developer productivity they provide form the basis of the application model. Java EE is designed to support applications that implement enterprise services for customers, employees, suppliers, partners, and others who make demands on or contributions to the enterprise. Such applications are inherently complex, potentially accessing data from a variety of sources and distributing applications to a variety of clients.</p>

      <p>To better control and manage these applications, the business functions to support these various users are conducted in the middle tier. The middle tier represents an environment that is closely controlled by an enterprise's information technology department. The middle tier is typically run on dedicated server hardware and has access to the full services of the enterprise.</p>

      <p>The Java EE application model defines an architecture for implementing services as multitier applications that deliver the scalability, accessibility, and manageability needed by enterprise-level applications. This model partitions the work needed to implement a multitier service into the following parts:</p>

      <ul>
        <li>
          <p>The business and presentation logic to be implemented by the developer</p>
        </li>

        <li>
          <p>The standard system services provided by the Java EE platform</p>
        </li>
      </ul>

      <p>The developer can rely on the platform to provide solutions for the hard systems-level problems of developing a multitier service.</p>
    </div>
  </div>

  <div class="ind">
    <a id="BNAAY"></a><a id="JEETT00308"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.3</span> <a id="sthref6"></a><a id="sthref7"></a><a id="sthref8"></a>Distributed Multitiered Applications</h1>

      <p>The Java EE platform uses a distributed multitiered application model for enterprise applications. Application logic is divided into components according to function, and the application components that make up a Java EE application are installed on various machines depending on the tier in the multitiered Java EE environment to which the application component belongs.</p>

      <p><a href="../Text/overview.xhtml#BNAAZ">Figure 1-1</a> shows two multitiered Java EE applications divided into the tiers described in the following list. The Java EE application parts shown in <a href="../Text/overview.xhtml#BNAAZ">Figure 1-1</a> are presented in <a href="../Text/overview.xhtml#BNABB">Java EE Components</a>.</p>

      <ul>
        <li>
          <p>Client-tier components run on the client machine.</p>
        </li>

        <li>
          <p>Web-tier components run on the Java EE server.</p>
        </li>

        <li>
          <p>Business-tier components run on the Java EE server.</p>
        </li>

        <li>
          <p>Enterprise information system (EIS)-tier software runs on the EIS server.</p>
        </li>
      </ul>

      <p><a id="sthref9"></a>Although a Java EE application can consist of all tiers shown in <a href="../Text/overview.xhtml#BNAAZ">Figure 1-1</a>, Java EE multitiered applications are generally considered to be three-tiered applications because they are distributed over three locations: client machines, the Java EE server machine, and the database or legacy machines at the back end. Three-tiered applications that run in this way extend the standard two-tiered client-and-server model by placing a multithreaded application server between the client application and back-end storage.</p>

      <div class="figure">
        <a id="BNAAZ"></a><a id="JEETT00001"></a>

        <p class="titleinfigure">Figure 1-1 Multitiered Applications</p>

        <div style="text-align: center;"><img alt="Description of Figure 1-1 follows" longdesc="img_text/jeett_dt_001.htm" src="../Images/jeett_dt_001.png" style="line-height: 1.6em;" title="Description of Figure 1-1 follows" /></div>Description of "Figure 1-1 Multitiered Applications"<br />
      </div><a id="BNABA"></a><a id="JEETT00843"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.1</span> Security</h2>

        <p>Although other enterprise application models require platform-specific security measures in each application, the Java EE security environment enables security constraints to be defined at deployment time. The Java EE platform makes applications portable to a wide variety of security implementations by shielding application developers from the complexity of implementing security features.</p>

        <p>The Java EE platform provides standard declarative access control rules that are defined by the developer and interpreted when the application is deployed on the server. Java EE also provides standard login mechanisms so that application developers do not have to implement these mechanisms in their applications. The same application works in a variety of security environments without changing the source code.</p>
      </div><a id="BNABB"></a><a id="JEETT00844"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.2</span> <a id="sthref11"></a><a id="sthref12"></a>Java EE Components</h2>

        <p>Java EE applications are made up of components. A <span class="glossaryterm">Java EE component</span> is a self-contained functional software unit that is assembled into a Java EE application with its related classes and files and that communicates with other components.</p>

        <p>The Java EE specification defines the following Java EE components:</p>

        <ul>
          <li>
            <p>Application clients and applets are components that run on the client.</p>
          </li>

          <li>
            <p>Java Servlet, JavaServer Faces, and JavaServer Pages (JSP) technology components are web components that run on the server.</p>
          </li>

          <li>
            <p>EJB components (enterprise beans) are business components that run on the server.</p>
          </li>
        </ul>

        <p>Java EE components are written in the Java programming language and are compiled in the same way as any program in the language. The differences between Java EE components and "standard" Java classes are that Java EE components are assembled into a Java EE application, they are verified to be well formed and in compliance with the Java EE specification, and they are deployed to production, where they are run and managed by the Java EE server.</p>
      </div><a id="BNABC"></a><a id="JEETT00845"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.3</span> <a id="sthref13"></a>Java EE Clients</h2>

        <p>A Java EE client is usually either a web client or an application client.</p><a id="BNABD"></a><a id="JEETT00576"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">1.3.3.1</span> <a id="sthref14"></a>Web Clients</h3>

          <p>A <span class="glossaryterm">web client</span> consists of two parts:</p>

          <ul>
            <li>
              <p>Dynamic web pages containing various types of markup language (HTML, XML, and so on), which are generated by web components running in the web tier</p>
            </li>

            <li>
              <p>A web browser, which renders the pages received from the server</p>
            </li>
          </ul>

          <p>A web client is sometimes called a <span class="glossaryterm">thin client</span>. Thin clients usually do not query databases, execute complex business rules, or connect to legacy applications. When you use a thin client, such heavyweight operations are off-loaded to enterprise beans executing on the Java EE server, where they can leverage the security, speed, services, and reliability of Java EE server-side technologies.</p>
        </div><a id="BNABF"></a><a id="JEETT00577"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">1.3.3.2</span> <a id="sthref15"></a>Application Clients</h3>

          <p>An <span class="glossaryterm">application client</span> runs on a client machine and provides a way for users to handle tasks that require a richer user interface than can be provided by a markup language. An application client typically has a graphical user interface (GUI) created from the Swing API or the Abstract Window Toolkit (AWT) API, but a command-line interface is certainly possible.</p>

          <p>Application clients directly access enterprise beans running in the business tier. However, if application requirements warrant it, an application client can open an HTTP connection to establish communication with a servlet running in the web tier. Application clients written in languages other than Java can interact with Java EE servers, enabling the Java EE platform to interoperate with legacy systems, clients, and non-Java languages.</p>
        </div><a id="BNABE"></a><a id="JEETT00578"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">1.3.3.3</span> <a id="sthref16"></a>Applets</h3>

          <p>A web page received from the web tier can include an embedded applet. Written in the Java programming language, an <span class="glossaryterm">applet</span> is a small client application that executes in the Java virtual machine installed in the web browser. However, client systems will likely need the Java Plug-in and possibly a security policy file for the applet to successfully execute in the web browser.</p>

          <p>Web components are the preferred API for creating a web client program because no plug-ins or security policy files are needed on the client systems. Also, web components enable cleaner and more modular application design because they provide a way to separate applications programming from web page design. Personnel involved in web page design thus do not need to understand Java programming language syntax to do their jobs.</p>
        </div><a id="BNABG"></a><a id="JEETT00579"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">1.3.3.4</span> <a id="sthref17"></a>The JavaBeans Component Architecture</h3>

          <p>The server and client tiers might also include components based on the JavaBeans component architecture (JavaBeans components) to manage the data flow between the following:</p>

          <ul>
            <li>
              <p>An application client or applet and components running on the Java EE server</p>
            </li>

            <li>
              <p>Server components and a database</p>
            </li>
          </ul>

          <p>JavaBeans components are not considered Java EE components by the Java EE specification.</p>

          <p>JavaBeans components have properties and have <code>get</code> and <code>set</code> methods for accessing those properties. JavaBeans components used in this way are typically simple in design and implementation but should conform to the naming and design conventions outlined in the JavaBeans component architecture.</p>
        </div><a id="BNABH"></a><a id="JEETT00580"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">1.3.3.5</span> Java EE Server Communications</h3>

          <p><a href="../Text/overview.xhtml#BNABI">Figure 1-2</a> shows the various elements that can make up the client tier. The client communicates with the business tier running on the Java EE server either directly or, as in the case of a client running in a browser, by going through web pages or servlets running in the web tier.</p>

          <div class="figure">
            <a id="BNABI"></a><a id="JEETT00002"></a>

            <p class="titleinfigure">Figure 1-2 Server Communication</p>

            <div style="text-align: center;"><img alt="Description of Figure 1-2 follows" longdesc="img_text/jeett_dt_002.htm" src="../Images/jeett_dt_002.png" style="line-height: 1.6em;" title="Description of Figure 1-2 follows" /></div>Description of "Figure 1-2 Server Communication"<br />
          </div>

          <div class="figure">
            <br />
          </div>
        </div>
      </div><a id="BNABJ"></a><a id="JEETT00846"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.4</span> <a id="sthref19"></a><a id="sthref20"></a>Web Components</h2>

        <p><a id="sthref21"></a><a id="sthref22"></a>Java EE web components are either servlets or web pages created using JavaServer Faces technology and/or JSP technology (JSP pages). <span class="glossaryterm">Servlets</span> are Java programming language classes that dynamically process requests and construct responses. <span class="glossaryterm">JSP pages</span> are text-based documents that execute as servlets but allow a more natural approach to creating static content. <span class="glossaryterm">JavaServer Faces technology</span> builds on servlets and JSP technology and provides a user interface component framework for web applications.</p>

        <p><a id="sthref23"></a><a id="sthref24"></a><a id="sthref25"></a>Static HTML pages and applets are bundled with web components during application assembly but are not considered web components by the Java EE specification. Server-side utility classes can also be bundled with web components and, like HTML pages, are not considered web components.</p>

        <p>As shown in <a href="../Text/overview.xhtml#BNABM">Figure 1-3</a>, the web tier, like the client tier, might include a JavaBeans component to manage the user input and send that input to enterprise beans running in the business tier for processing.</p>

        <div class="figure">
          <a id="BNABM"></a><a id="JEETT00003"></a>

          <p class="titleinfigure">Figure 1-3 Web Tier and Java EE Applications</p>

          <div style="text-align: center;"><img alt="Description of Figure 1-3 follows" longdesc="img_text/jeett_dt_003.htm" src="../Images/jeett_dt_003.png" style="line-height: 1.6em;" title="Description of Figure 1-3 follows" /></div>Description of "Figure 1-3 Web Tier and Java EE Applications"<br />
        </div>

        <div class="figure">
          <br />
        </div>
      </div><a id="BNABK"></a><a id="JEETT00847"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.5</span> <a id="sthref27"></a><a id="sthref28"></a>Business Components</h2>

        <p>Business code, which is logic that solves or meets the needs of a particular business domain such as banking, retail, or finance, is handled by enterprise beans running in either the business tier or the web tier. <a href="../Text/overview.xhtml#BNABN">Figure 1-4</a> shows how an enterprise bean receives data from client programs, processes it (if necessary), and sends it to the enterprise information system tier for storage. An enterprise bean also retrieves data from storage, processes it (if necessary), and sends it back to the client program.</p>

        <div class="figure">
          <a id="BNABN"></a><a id="JEETT00004"></a>

          <p class="titleinfigure">Figure 1-4 Business and EIS Tiers</p>

          <div style="text-align: center;"><img alt="Description of Figure 1-4 follows" longdesc="img_text/jeett_dt_004.htm" src="../Images/jeett_dt_004.png" style="line-height: 1.6em;" title="Description of Figure 1-4 follows" /></div>Description of "Figure 1-4 Business and EIS Tiers"<br />
        </div>

        <div class="figure">
          <br />
        </div>
      </div><a id="BNABL"></a><a id="JEETT00848"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.3.6</span> <a id="sthref30"></a>Enterprise Information System Tier</h2>

        <p>The enterprise information system tier handles EIS software and includes enterprise infrastructure systems, such as enterprise resource planning (ERP), mainframe transaction processing, database systems, and other legacy information systems. For example, Java EE application components might need access to enterprise information systems for database connectivity.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNABO"></a><a id="JEETT00309"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.4</span> <a id="sthref31"></a>Java EE Containers</h1>

      <p>Normally, thin-client multitiered applications are hard to write because they involve many lines of intricate code to handle transaction and state management, multithreading, resource pooling, and other complex low-level details. The component-based and platform-independent Java EE architecture makes applications easy to write because business logic is organized into reusable components. In addition, the Java EE server provides underlying services in the form of a container for every component type. Because you do not have to develop these services yourself, you are free to concentrate on solving the business problem at hand.</p><a id="BNABP"></a><a id="JEETT00849"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.4.1</span> <a id="sthref32"></a>Container Services</h2>

        <p><span class="glossaryterm">Containers</span> are the interface between a component and the low-level, platform-specific functionality that supports the component. Before it can be executed, a web, enterprise bean, or application client component must be assembled into a Java EE module and deployed into its container.</p>

        <p>The assembly process involves specifying container settings for each component in the Java EE application and for the Java EE application itself. Container settings customize the underlying support provided by the Java EE server, including such services as security, transaction management, Java Naming and Directory Interface (JNDI) API lookups, and remote connectivity. Here are some of the highlights.</p>

        <ul>
          <li>
            <p><a id="sthref33"></a>The Java EE security model lets you configure a web component or enterprise bean so that system resources are accessed only by authorized users.</p>
          </li>

          <li>
            <p><a id="sthref34"></a>The Java EE transaction model lets you specify relationships among methods that make up a single transaction so that all methods in one transaction are treated as a single unit.</p>
          </li>

          <li>
            <p>JNDI lookup services provide a unified interface to multiple naming and directory services in the enterprise so that application components can access these services.</p>
          </li>

          <li>
            <p>The Java EE remote connectivity model manages low-level communications between clients and enterprise beans. After an enterprise bean is created, a client invokes methods on it as if it were in the same virtual machine.</p>
          </li>
        </ul>

        <p><a id="sthref35"></a>Because the Java EE architecture provides configurable services, components within the same application can behave differently based on where they are deployed. For example, an enterprise bean can have security settings that allow it a certain level of access to database data in one production environment and another level of database access in another production environment.</p>

        <p><a id="sthref36"></a>The container also manages nonconfigurable services, such as enterprise bean and servlet lifecycles, database connection resource pooling, data persistence, and access to the Java EE platform APIs (see <a href="../Text/overview.xhtml#BNACJ">Java EE 7 APIs</a>).</p>
      </div><a id="BNABQ"></a><a id="JEETT00850"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.4.2</span> Container Types</h2>

        <p>The <span class="glossaryterm">deployment</span> process installs Java EE application components in the Java EE containers, as illustrated in <a href="../Text/overview.xhtml#BNABR">Figure 1-5</a>.</p>

        <div class="figure">
          <a id="BNABR"></a><a id="JEETT00005"></a>

          <p class="titleinfigure">Figure 1-5 Java EE Server and Containers</p><img alt="Description of Figure 1-5 follows" longdesc="img_text/jeett_dt_005.htm" src="../Images/jeett_dt_005.png" title="Description of Figure 1-5 follows" /><br />
          <a href="../Text/overview.xhtml#img_text/jeett_dt_005.htm" id="sthref37">Description of "Figure 1-5 Java EE Server and Containers"</a><br />
          <br />
        </div>

        <p>The server and containers are as follows:</p>

        <ul>
          <li>
            <p><a id="sthref38"></a><span class="bold">Java EE server</span>: The runtime portion of a Java EE product. A Java EE server provides EJB and web containers.</p>
          </li>

          <li>
            <p><a id="sthref39"></a><span class="bold">EJB container</span>: Manages the execution of enterprise beans for Java EE applications. Enterprise beans and their container run on the Java EE server.</p>
          </li>

          <li>
            <p><a id="sthref40"></a><span class="bold">Web container</span>: Manages the execution of web pages, servlets, and some EJB components for Java EE applications. Web components and their container run on the Java EE server.</p>
          </li>

          <li>
            <p><a id="sthref41"></a><a id="sthref42"></a><span class="bold">Application client container</span>: Manages the execution of application client components. Application clients and their container run on the client.</p>
          </li>

          <li>
            <p><a id="sthref43"></a><span class="bold">Applet container</span>: Manages the execution of applets. Consists of a web browser and a Java Plug-in running on the client together.</p>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNABS"></a><a id="JEETT00310"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.5</span> <a id="sthref44"></a>Web Services Support</h1>

      <p>Web services are web-based enterprise applications that use open, XML-based standards and transport protocols to exchange data with calling clients. The Java EE platform provides the XML APIs and tools you need to quickly design, develop, test, and deploy web services and clients that fully interoperate with other web services and clients running on Java-based or non-Java-based platforms.</p>

      <p>To write web services and clients with the Java EE XML APIs, all you need to do is pass parameter data to the method calls and process the data returned; for document-oriented web services, you send documents containing the service data back and forth. No low-level programming is needed because the XML API implementations do the work of translating the application data to and from an XML-based data stream that is sent over the standardized XML-based transport protocols. These XML-based standards and protocols are introduced in the following sections.</p>

      <p>The translation of data to a standardized XML-based data stream is what makes web services and clients written with the Java EE XML APIs fully interoperable. This does not necessarily mean that the data being transported includes XML tags, because the transported data can itself be plain text, XML data, or any kind of binary data, such as audio, video, maps, program files, computer-aided design (CAD) documents, and the like. The next section introduces XML and explains how parties doing business can use XML tags and schemas to exchange data in a meaningful way.</p><a id="BNABT"></a><a id="JEETT00851"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.5.1</span> <a id="sthref45"></a>XML</h2>

        <p>Extensible Markup Language (XML) is a cross-platform, extensible, text-based standard for representing data. Parties that exchange XML data can create their own tags to describe the data, set up schemas to specify which tags can be used in a particular kind of XML document, and use XML style sheets to manage the display and handling of the data.</p>

        <p>For example, a web service can use XML and a schema to produce price lists, and companies that receive the price lists and schema can have their own style sheets to handle the data in a way that best suits their needs. Here are examples.</p>

        <ul>
          <li>
            <p>One company might put XML pricing information through a program to translate the XML into HTML so that it can post the price lists to its intranet.</p>
          </li>

          <li>
            <p>A partner company might put the XML pricing information through a tool to create a marketing presentation.</p>
          </li>

          <li>
            <p>Another company might read the XML pricing information into an application for processing.</p>
          </li>
        </ul>
      </div><a id="BNABU"></a><a id="JEETT00852"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.5.2</span> <a id="sthref46"></a>SOAP Transport Protocol</h2>

        <p>Client requests and web service responses are transmitted as Simple Object Access Protocol (SOAP) messages over HTTP to enable a completely interoperable exchange between clients and web services, all running on different platforms and at various locations on the Internet. HTTP is a familiar request-and-response standard for sending messages over the Internet, and SOAP is an XML-based protocol that follows the HTTP request-and-response model.</p>

        <p>The SOAP portion of a transported message does the following:</p>

        <ul>
          <li>
            <p>Defines an XML-based envelope to describe what is in the message and explain how to process the message</p>
          </li>

          <li>
            <p>Includes XML-based encoding rules to express instances of application-defined data types within the message</p>
          </li>

          <li>
            <p>Defines an XML-based convention for representing the request to the remote service and the resulting response</p>
          </li>
        </ul>
      </div><a id="BNABV"></a><a id="JEETT00853"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.5.3</span> <a id="sthref47"></a>WSDL Standard Format</h2>

        <p>The Web Services Description Language (WSDL) is a standardized XML format for describing network services. The description includes the name of the service, the location of the service, and ways to communicate with the service. WSDL service descriptions can be published on the Web. GlassFish Server provides a tool for generating the WSDL specification of a web service that uses remote procedure calls to communicate with clients.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNABX"></a><a id="JEETT00311"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.6</span> Java EE Application Assembly and Deployment</h1>

      <p>A Java EE application is packaged into one or more standard units for deployment to any Java EE platform-compliant system. Each unit contains</p>

      <ul>
        <li>
          <p>A functional component or components, such as an enterprise bean, web page, servlet, or applet</p>
        </li>

        <li>
          <p>An optional deployment descriptor that describes its content</p>
        </li>
      </ul>

      <p>Once a Java EE unit has been produced, it is ready to be deployed. Deployment typically involves using a platform's deployment tool to specify location-specific information, such as a list of local users who can access it and the name of the local database. Once deployed on a local platform, the application is ready to run.</p>
    </div>
  </div>

  <div class="ind">
    <a id="BNACJ"></a><a id="JEETT00314"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.7</span> <a id="sthref48"></a>Java EE 7 APIs</h1>

      <p><a href="../Text/overview.xhtml#BNACK">Figure 1-6</a> shows the relationships among the Java EE containers.</p>

      <div class="figure">
        <a id="BNACK"></a><a id="JEETT00007"></a>

        <p class="titleinfigure">Figure 1-6 Java EE Containers</p>

        <div style="text-align: center;"><img alt="Description of Figure 1-6 follows" longdesc="img_text/jeett_dt_006.htm" src="../Images/jeett_dt_006.png" style="line-height: 1.6em;" title="Description of Figure 1-6 follows" /></div>
      </div>

      <div class="figure">
        Description of "Figure 1-6 Java EE Containers"<br />
        <br />
      </div>

      <p><a href="../Text/overview.xhtml#GJQMG">Figure 1-7</a> shows the availability of the Java EE 7 APIs in the web container.</p>

      <div class="figure">
        <a id="GJQMG"></a><a id="JEETT00008"></a>

        <p class="titleinfigure">Figure 1-7 Java EE APIs in the Web Container</p>

        <div style="text-align: center;"><img alt="Description of Figure 1-7 follows" longdesc="img_text/jeett_dt_007.htm" src="../Images/jeett_dt_007.png" style="line-height: 1.6em;" title="Description of Figure 1-7 follows" /></div>
      </div>

      <div class="figure">
        Description of "Figure 1-7 Java EE APIs in the Web Container"<br />
        <br />
      </div>

      <p><a href="../Text/overview.xhtml#GJQMN">Figure 1-8</a> shows the availability of the Java EE 7 APIs in the EJB container.</p>

      <div class="figure">
        <a id="GJQMN"></a><a id="JEETT00009"></a>

        <p class="titleinfigure">Figure 1-8 Java EE APIs in the EJB Container</p>

        <div style="text-align: center;"><img alt="Description of Figure 1-8 follows" longdesc="img_text/jeett_dt_008.htm" src="../Images/jeett_dt_008.png" style="line-height: 1.6em;" title="Description of Figure 1-8 follows" /></div>
      </div>

      <div class="figure">
        Description of "Figure 1-8 Java EE APIs in the EJB Container"<br />
        <br />
      </div>

      <p><a href="../Text/overview.xhtml#GJQNH">Figure 1-9</a> shows the availability of the Java EE 7 APIs in the application client container.</p>

      <div class="figure">
        <a id="GJQNH"></a><a id="JEETT00010"></a>

        <p class="titleinfigure">Figure 1-9 Java EE APIs in the Application Client Container</p>

        <div style="text-align: center;"><img alt="Description of Figure 1-9 follows" longdesc="img_text/jeett_dt_009.htm" src="../Images/jeett_dt_009.png" style="line-height: 1.6em;" title="Description of Figure 1-9 follows" /></div>
      </div>

      <div class="figure">
        Description of "Figure 1-9 Java EE APIs in the Application Client Container"<br />
        <br />
      </div>

      <p>The following sections give a brief summary of the technologies required by the Java EE platform and the APIs used in Java EE applications.</p><a id="BNACL"></a><a id="JEETT00859"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.1</span> <a id="sthref53"></a>Enterprise JavaBeans Technology</h2>

        <p>An <span class="glossaryterm">Enterprise JavaBeans (EJB) component</span>, or <span class="glossaryterm">enterprise bean</span>, is a body of code that has fields and methods to implement modules of business logic. You can think of an enterprise bean as a building block that can be used alone or with other enterprise beans to execute business logic on the Java EE server.</p>

        <p><a id="sthref54"></a><a id="sthref55"></a>Enterprise beans are either session beans or message-driven beans.</p>

        <ul>
          <li>
            <p>A <span class="glossaryterm">session bean</span> represents a transient conversation with a client. When the client finishes executing, the session bean and its data are gone.</p>
          </li>

          <li>
            <p>A <span class="glossaryterm">message-driven bean</span> combines features of a session bean and a message listener, allowing a business component to receive messages asynchronously. Commonly, these are Java Message Service (JMS) messages.</p>
          </li>
        </ul>

        <p>In the Java EE 7 platform, new enterprise bean features include the following:</p>

        <ul>
          <li>
            <p>Asynchronous local session beans in EJB Lite</p>
          </li>

          <li>
            <p>Nonpersistent timers in EJB Lite</p>
          </li>
        </ul>

        <p>The Java EE 7 platform requires Enterprise JavaBeans 3.2 and Interceptors 1.2. The Interceptors specification is part of the EJB specification.</p>
      </div><a id="BNACM"></a><a id="JEETT00860"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.2</span> <a id="sthref56"></a>Java Servlet Technology</h2>

        <p>Java Servlet technology lets you define HTTP-specific servlet classes. A servlet class extends the capabilities of servers that host applications accessed by way of a request-response programming model. Although servlets can respond to any type of request, they are commonly used to extend the applications hosted by web servers.</p>

        <p>In the Java EE 7 platform, new Java Servlet technology features include the following:</p>

        <ul>
          <li>
            <p>Nonblocking I/O</p>
          </li>

          <li>
            <p>HTTP protocol upgrade</p>
          </li>
        </ul>

        <p>The Java EE 7 platform requires Servlet 3.1.</p>
      </div><a id="BNACP"></a><a id="JEETT00861"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.3</span> <a id="sthref57"></a>JavaServer Faces Technology</h2>

        <p>JavaServer Faces technology is a user interface framework for building web applications. The main components of JavaServer Faces technology are as follows:</p>

        <ul>
          <li>
            <p>A GUI component framework.</p>
          </li>

          <li>
            <p>A flexible model for rendering components in different kinds of HTML or different markup languages and technologies. A <code>Renderer</code> object generates the markup to render the component and converts the data stored in a model object to types that can be represented in a view.</p>
          </li>

          <li>
            <p>A standard <code>RenderKit</code> for generating HTML 4.01 markup.</p>
          </li>
        </ul>

        <p>The following features support the GUI components:</p>

        <ul>
          <li>
            <p>Input validation</p>
          </li>

          <li>
            <p>Event handling</p>
          </li>

          <li>
            <p>Data conversion between model objects and components</p>
          </li>

          <li>
            <p>Managed model object creation</p>
          </li>

          <li>
            <p>Page navigation configuration</p>
          </li>

          <li>
            <p>Expression Language (EL)</p>
          </li>
        </ul>

        <p>All this functionality is available using standard Java APIs and XML-based configuration files.</p>

        <p>In the Java EE 7 platform, new features of JavaServer Faces technology include the following:</p>

        <ul>
          <li>
            <p>HTML5-friendly markup</p>
          </li>

          <li>
            <p>Faces Flows</p>
          </li>

          <li>
            <p>Resource library contracts</p>
          </li>
        </ul>

        <p>The Java EE 7 platform requires JavaServer Faces 2.2 and Expression Language 3.0.</p>
      </div><a id="BNACN"></a><a id="JEETT00862"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.4</span> <a id="sthref58"></a>JavaServer Pages Technology</h2>

        <p>JavaServer Pages (JSP) technology lets you put snippets of servlet code directly into a text-based document. A JSP page is a text-based document that contains two types of text:</p>

        <ul>
          <li>
            <p>Static data, which can be expressed in any text-based format, such as HTML or XML</p>
          </li>

          <li>
            <p>JSP elements, which determine how the page constructs dynamic content</p>
          </li>
        </ul>

        <p>For information about JSP technology, see the <span class="italic">The Java EE 5 Tutorial</span> at <code><a href="../Text/overview.xhtml#http%3A//docs.oracle.com/javaee/5/tutorial/doc/">http://docs.oracle.com/javaee/5/tutorial/doc/</a></code>.</p>

        <p>The Java EE 7 platform requires JavaServer Pages 2.3 for compatibility with earlier releases but recommends the use of Facelets as the display technology in new applications.</p>
      </div><a id="BNACO"></a><a id="JEETT00863"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.5</span> <a id="sthref59"></a><a id="sthref60"></a>JavaServer Pages Standard Tag Library</h2>

        <p>The JavaServer Pages Standard Tag Library (JSTL) encapsulates core functionality common to many JSP applications. Instead of mixing tags from numerous vendors in your JSP applications, you use a single, standard set of tags. This standardization allows you to deploy your applications on any JSP container that supports JSTL and makes it more likely that the implementation of the tags is optimized.</p>

        <p>JSTL has iterator and conditional tags for handling flow control, tags for manipulating XML documents, internationalization tags, tags for accessing databases using SQL, and tags for commonly used functions.</p>

        <p>The Java EE 7 platform requires JSTL 1.2.</p>
      </div><a id="BNADB"></a><a id="JEETT00864"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.6</span> <a id="sthref61"></a>Java Persistence API</h2>

        <p>The Java Persistence API (JPA) is a Java standardsbased solution for persistence. Persistence uses an object/relational mapping approach to bridge the gap between an object-oriented model and a relational database. The Java Persistence API can also be used in Java SE applications outside of the Java EE environment. Java Persistence consists of the following areas:</p>

        <ul>
          <li>
            <p>The Java Persistence API</p>
          </li>

          <li>
            <p>The query language</p>
          </li>

          <li>
            <p>Object/relational mapping metadata</p>
          </li>
        </ul>

        <p>The Java EE 7 platform requires Java Persistence API 2.1.</p>
      </div><a id="BNACR"></a><a id="JEETT00865"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.7</span> <a id="sthref62"></a><a id="sthref63"></a><a id="sthref64"></a>Java Transaction API</h2>

        <p>The Java Transaction API (JTA) provides a standard interface for demarcating transactions. The Java EE architecture provides a default auto commit to handle transaction commits and rollbacks. An auto commit means that any other applications that are viewing data will see the updated data after each database read or write operation. However, if your application performs two separate database access operations that depend on each other, you will want to use the JTA API to demarcate where the entire transaction, including both operations, begins, rolls back, and commits.</p>

        <p>The Java EE 7 platform requires Java Transaction API 1.2.</p>
      </div><a id="GIRBT"></a><a id="JEETT00866"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.8</span> <a id="sthref65"></a><a id="sthref66"></a>Java API for RESTful Web Services</h2>

        <p>The Java API for RESTful Web Services (JAX-RS) defines APIs for the development of web services built according to the Representational State Transfer (REST) architectural style. A JAX-RS application is a web application that consists of classes packaged as a servlet in a WAR file along with required libraries.</p>

        <p>The Java EE 7 platform requires JAX-RS 2.0.</p>
      </div><a id="GJXSD"></a><a id="JEETT00867"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.9</span> <a id="sthref67"></a>Managed Beans</h2>

        <p><span class="glossaryterm">Managed Beans</span>, lightweight container-managed objects (POJOs) with minimal requirements, support a small set of basic services, such as resource injection, lifecycle callbacks, and interceptors. Managed Beans represent a generalization of the managed beans specified by JavaServer Faces technology and can be used anywhere in a Java EE application, not just in web modules.</p>

        <p>The Managed Beans specification is part of the Java EE 7 platform specification (JSR 342). The Java EE 7 platform requires Managed Beans 1.0.</p>
      </div><a id="GJXVO"></a><a id="JEETT00868"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.10</span> <a id="sthref68"></a>Contexts and Dependency Injection for Java EE</h2>

        <p>Contexts and Dependency Injection for Java EE (CDI) defines a set of contextual services, provided by Java EE containers, that make it easy for developers to use enterprise beans along with JavaServer Faces technology in web applications. Designed for use with stateful objects, CDI also has many broader uses, allowing developers a great deal of flexibility to integrate different kinds of components in a loosely coupled but typesafe way.</p>

        <p>The Java EE 7 platform requires CDI 1.1.</p>
      </div><a id="GJXVG"></a><a id="JEETT00869"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.11</span> <a id="sthref69"></a>Dependency Injection for Java</h2>

        <p>Dependency Injection for Java defines a standard set of annotations (and one interface) for use on injectable classes.</p>

        <p>In the Java EE platform, CDI provides support for Dependency Injection. Specifically, you can use injection points only in a CDI-enabled application.</p>

        <p>The Java EE 7 platform requires Dependency Injection for Java 1.0.</p>
      </div><a id="GJXTY"></a><a id="JEETT00870"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.12</span> <a id="sthref70"></a>Bean Validation</h2>

        <p>The Bean Validation specification defines a metadata model and API for validating data in JavaBeans components. Instead of distributing validation of data over several layers, such as the browser and the server side, you can define the validation constraints in one place and share them across the different layers.</p>

        <p>The Java EE 7 platform requires Bean Validation 1.1.</p>
      </div><a id="BNACQ"></a><a id="JEETT00871"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.13</span> <a id="sthref71"></a><a id="sthref72"></a>Java Message Service API</h2>

        <p>The Java Message Service (JMS) API is a messaging standard that allows Java EE application components to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous.</p>

        <p>In the platform, new features of JMS include the following.</p>

        <ul>
          <li>
            <p>A new, simplified API offers a simpler alternative to the previous API. This API includes a <code>JMSContext</code> object that combines the functions of a <code>Connection</code> and a <code>Session</code>.</p>
          </li>

          <li>
            <p>All objects with a <code>close</code> method implement the <code>java.lang.Autocloseable</code> interface so that they can be used in a Java SE 7 <code>try</code>-with-resources statement.</p>
          </li>
        </ul>

        <p>The Java EE 7 platform requires JMS 2.0.</p>
      </div><a id="BNACZ"></a><a id="JEETT00872"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.14</span> <a id="sthref73"></a><a id="sthref74"></a>Java EE Connector Architecture</h2>

        <p>The Java EE Connector Architecture is used by tools vendors and system integrators to create resource adapters that support access to enterprise information systems that can be plugged in to any Java EE product. A <span class="glossaryterm">resource adapter</span> is a software component that allows Java EE application components to access and interact with the underlying resource manager of the EIS. Because a resource adapter is specific to its resource manager, a different resource adapter typically exists for each type of database or enterprise information system.</p>

        <p>The Java EE Connector Architecture also provides a performance-oriented, secure, scalable, and message-based transactional integration of Java EE platformbased web services with existing EISs that can be either synchronous or asynchronous. Existing applications and EISs integrated through the Java EE Connector Architecture into the Java EE platform can be exposed as XML-based web services by using JAX-WS and Java EE component models. Thus JAX-WS and the Java EE Connector Architecture are complementary technologies for enterprise application integration (EAI) and end-to-end business integration.</p>

        <p>The Java EE 7 platform requires Java EE Connector Architecture 1.7.</p>
      </div><a id="BNACS"></a><a id="JEETT00873"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.15</span> <a id="sthref75"></a>JavaMail API</h2>

        <p>Java EE applications use the JavaMail API to send email notifications. The JavaMail API has two parts:</p>

        <ul>
          <li>
            <p>An application-level interface used by the application components to send mail</p>
          </li>

          <li>
            <p>A service provider interface</p>
          </li>
        </ul>

        <p>The Java EE platform includes the JavaMail API with a service provider that allows application components to send Internet mail.</p>

        <p>The Java EE 7 platform requires JavaMail 1.5.</p>
      </div><a id="GIRBE"></a><a id="JEETT00874"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.16</span> <a id="sthref76"></a>Java Authorization Contract for Containers</h2>

        <p>The Java Authorization Contract for Containers (JACC) specification defines a contract between a Java EE application server and an authorization policy provider. All Java EE containers support this contract.</p>

        <p>The JACC specification defines <code>java.security.Permission</code> classes that satisfy the Java EE authorization model. The specification defines the binding of container-access decisions to operations on instances of these permission classes. It defines the semantics of policy providers that use the new permission classes to address the authorization requirements of the Java EE platform, including the definition and use of roles.</p>

        <p>The Java EE 7 platform requires JACC 1.5.</p>
      </div><a id="GIRGP"></a><a id="JEETT00875"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.17</span> <a id="sthref77"></a><a id="sthref78"></a>Java Authentication Service Provider Interface for Containers</h2>

        <p>The Java Authentication Service Provider Interface for Containers (JASPIC) specification defines a service provider interface (SPI) by which authentication providers that implement message authentication mechanisms may be integrated in client or server message-processing containers or runtimes. Authentication providers integrated through this interface operate on network messages provided to them by their calling containers. The authentication providers transform outgoing messages so that the source of each message can be authenticated by the receiving container, and the recipient of the message can be authenticated by the message sender. Authentication providers authenticate each incoming message and return to their calling containers the identity established as a result of the message authentication.</p>

        <p>The Java EE 7 platform requires JASPIC 1.1.</p>
      </div><a id="CJAHDJBJ"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.18</span> <a id="sthref79"></a>Java API for WebSocket</h2>

        <p>WebSocket is an application protocol that provides full-duplex communications between two peers over TCP. The Java API for WebSocket enables Java EE applications to create endpoints using annotations that specify the configuration parameters of the endpoint and designate its lifecycle callback methods.</p>

        <p>The WebSocket API is new to the Java EE 7 platform. The Java EE 7 platform requires Java API for WebSocket 1.0.</p>
      </div><a id="CJAGIEEI"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.19</span> <a id="sthref80"></a>Java API for JSON Processing</h2>

        <p>JSON is a text-based data exchange format derived from JavaScript that is used in web services and other connected applications. The Java API for JSON Processing (JSON-P) enables Java EE applications to parse, transform, and query JSON data using the object model or the streaming model.</p>

        <p>JSON-P is new to the Java EE 7 platform. The Java EE 7 platform requires JSON-P 1.0.</p>
      </div><a id="CJAFGFCJ"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.20</span> <a id="sthref81"></a>Concurrency Utilities for Java EE</h2>

        <p>Concurrency Utilities for Java EE is a standard API for providing asynchronous capabilities to Java EE application components through the following types of objects: managed executor service, managed scheduled executor service, managed thread factory, and context service.</p>

        <p>Concurrency Utilities for Java EE is new to the Java EE 7 platform. The Java EE 7 platform requires Concurrency Utilities for Java EE 1.0.</p>
      </div><a id="CJAJHGIH"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.7.21</span> <a id="sthref82"></a>Batch Applications for the Java Platform</h2>

        <p>Batch jobs are tasks that can be executed without user interaction. The Batch Applications for the Java Platform specification is a batch framework that provides support for creating and running batch jobs in Java applications. The batch framework consists of a batch runtime, a job specification language based on XML, a Java API to interact with the batch runtime, and a Java API to implement batch artifacts.</p>

        <p>Batch Applications for the Java Platform is new to the Java EE 7 platform. The Java EE 7 platform requires Batch Applications for the Java Platform 1.0.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GIRDR"></a><a id="JEETT00315"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.8</span> Java EE 7 APIs in the Java Platform, Standard Edition 7</h1>

      <p>Several APIs that are required by the Java EE 7 platform are included in the Java Platform, Standard Edition 7 (Java SE 7) and are thus available to Java EE applications.</p><a id="BNADA"></a><a id="JEETT00876"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.1</span> <a id="sthref83"></a><a id="sthref84"></a>Java Database Connectivity API</h2>

        <p>The Java Database Connectivity (JDBC) API lets you invoke SQL commands from Java programming language methods. You use the JDBC API in an enterprise bean when you have a session bean access the database. You can also use the JDBC API from a servlet or a JSP page to access the database directly without going through an enterprise bean.</p>

        <p>The JDBC API has two parts:</p>

        <ul>
          <li>
            <p>An application-level interface used by the application components to access a database</p>
          </li>

          <li>
            <p>A service provider interface to attach a JDBC driver to the Java EE platform</p>
          </li>
        </ul>

        <p>The Java SE 7 platform requires JDBC 4.1.</p>
      </div><a id="BNADC"></a><a id="JEETT00877"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.2</span> <a id="sthref85"></a>Java Naming and Directory Interface API</h2>

        <p>The Java Naming and Directory Interface (JNDI) API provides naming and directory functionality, enabling applications to access multiple naming and directory services, such as LDAP, DNS, and NIS. The JNDI API provides applications with methods for performing standard directory operations, such as associating attributes with objects and searching for objects using their attributes. Using JNDI, a Java EE application can store and retrieve any type of named Java object, allowing Java EE applications to coexist with many legacy applications and systems.</p>

        <p><a id="sthref86"></a><a id="sthref87"></a><a id="sthref88"></a><a id="sthref89"></a>Java EE naming services provide application clients, enterprise beans, and web components with access to a JNDI naming environment. A <span class="glossaryterm">naming environment</span> allows a component to be customized without the need to access or change the component's source code. A container implements the component's environment and provides it to the component as a JNDI <span class="glossaryterm">naming context</span>.</p>

        <p><a id="sthref90"></a><a id="sthref91"></a><a id="sthref92"></a>The naming environment provides four logical namespaces: <code>java:comp</code>, <code>java:module</code>, <code>java:app</code>, and <code>java:global</code> for objects available to components, modules, or applications or shared by all deployed applications. A Java EE component can access named system-provided and user-defined objects. The names of some system-provided objects, such as a default JDBC <code>DataSource</code> object, a default JMS connection factory, and a JTA <code>UserTransaction</code> object, are stored in the <code>java:comp</code> namespace. The Java EE platform allows a component to name user-defined objects, such as enterprise beans, environment entries, JDBC <code>DataSource</code> objects, and messaging destinations.</p>

        <p><a id="sthref93"></a><a id="sthref94"></a>A Java EE component can also locate its environment naming context by using JNDI interfaces. A component can create a <code>javax.naming.InitialContext</code> object and look up the environment naming context in <code>InitialContext</code> under the name <code>java:comp/env</code>. A component's naming environment is stored directly in the environment naming context or in any of its direct or indirect subcontexts.</p>
      </div><a id="BNACT"></a><a id="JEETT00878"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.3</span> <a id="sthref95"></a><a id="sthref96"></a>JavaBeans Activation Framework</h2>

        <p>The JavaBeans Activation Framework (JAF) is used by the JavaMail API. JAF provides standard services to determine the type of an arbitrary piece of data, encapsulate access to it, discover the operations available on it, and create the appropriate JavaBeans component to perform those operations.</p>
      </div><a id="BNACU"></a><a id="JEETT00879"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.4</span> <a id="sthref97"></a><a id="sthref98"></a>Java API for XML Processing</h2>

        <p>The Java API for XML Processing (JAXP), part of the Java SE platform, supports the processing of XML documents using Document Object Model (DOM), Simple API for XML (SAX), and Extensible Stylesheet Language Transformations (XSLT). JAXP enables applications to parse and transform XML documents independently of a particular XML-processing implementation.</p>

        <p><a id="sthref99"></a>JAXP also provides namespace support, which lets you work with schemas that might otherwise have naming conflicts. Designed to be flexible, JAXP lets you use any XML-compliant parser or XSL processor from within your application and supports the Worldwide Web Consortium (W3C) schema. You can find information on the W3C schema at <code><a href="../Text/overview.xhtml#http%3A//www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a></code>.</p>
      </div><a id="BNACW"></a><a id="JEETT00880"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.5</span> <a id="sthref100"></a><a id="sthref101"></a>Java Architecture for XML Binding</h2>

        <p>The Java Architecture for XML Binding (JAXB) provides a convenient way to bind an XML schema to a representation in Java language programs. JAXB can be used independently or in combination with JAX-WS, in which case it provides a standard data binding for web service messages. All Java EE application client containers, web containers, and EJB containers support the JAXB API.</p>

        <p>The Java EE 7 platform requires JAXB 2.2.</p>
      </div><a id="BNACV"></a><a id="JEETT00882"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.6</span> <a id="sthref102"></a>Java API for XML Web Services</h2>

        <p>The Java API for XML Web Services (JAX-WS) specification provides support for web services that use the JAXB API for binding XML data to Java objects. The JAX-WS specification defines client APIs for accessing web services as well as techniques for implementing web service endpoints. The Implementing Enterprise Web Services specification describes the deployment of JAX-WS-based services and clients. The EJB and Java Servlet specifications also describe aspects of such deployment. JAX-WS-based applications can be deployed using any of these deployment models.</p>

        <p>The JAX-WS specification describes the support for message handlers that can process message requests and responses. In general, these message handlers execute in the same container and with the same privileges and execution context as the JAX-WS client or endpoint component with which they are associated. These message handlers have access to the same JNDI namespace as their associated component. Custom serializers and deserializers, if supported, are treated in the same way as message handlers.</p>

        <p>The Java EE 7 platform requires JAX-WS 2.2.</p>
      </div><a id="BNACX"></a><a id="JEETT00881"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.7</span> <a id="sthref103"></a><a id="sthref104"></a><a id="sthref105"></a>SOAP with Attachments API for Java</h2>

        <p>The SOAP with Attachments API for Java (SAAJ) is a low-level API on which JAX-WS depends. SAAJ enables the production and consumption of messages that conform to the SOAP 1.1 and 1.2 specifications and the SOAP with Attachments note. Most developers do not use the SAAJ API, instead using the higher-level JAX-WS API.</p>
      </div><a id="BNADD"></a><a id="JEETT00883"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">1.8.8</span> <a id="sthref106"></a>Java Authentication and Authorization Service</h2>

        <p>The Java Authentication and Authorization Service (JAAS) provides a way for a Java EE application to authenticate and authorize a specific user or group of users to run it.</p>

        <p>JAAS is a Java programming language version of the standard Pluggable Authentication Module (PAM) framework, which extends the Java platform security architecture to support user-based authorization.</p>
      </div>

      <div class="sect2">
        <a id="sthref107"></a>

        <h2 class="sect2"><span class="secnum">1.8.9</span> Common Annotations for the Java Platform</h2>

        <p>Annotations enable a declarative style of programming in the Java platform.</p>

        <p>The Java EE 7 platform requires Common Annotations for the Java Platform 1.2.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNADF"></a><a id="JEETT00316"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">1.9</span> <a id="sthref108"></a>GlassFish Server Tools</h1>

      <p>GlassFish Server is a compliant implementation of the Java EE 7 platform. In addition to supporting all the APIs described in the previous sections, GlassFish Server includes a number of Java EE tools that are not part of the Java EE 7 platform but are provided as a convenience to the developer.</p>

      <p>This section briefly summarizes the tools that make up GlassFish Server. Instructions for starting and stopping GlassFish Server, starting the Administration Console, and starting and stopping the Java DB server are in <a href="../Text/usingexamples.xhtml#GFIUD">Chapter 2, "Using the Tutorial Examples"</a>.</p>

      <p>GlassFish Server contains the tools listed in <a href="../Text/overview.xhtml#BNADH">Table 1-1</a>. Basic usage information for many of the tools appears throughout the tutorial. For detailed information, see the online help in the GUI tools.</p>

      <div class="tblhruleformal">
        <a id="sthref109"></a><a id="BNADH"></a>

        <p class="titleintable">Table 1-1 GlassFish Server Tools</p>

        <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table describes each GlassFish Server tool." title="GlassFish Server Tools" width="100%">
          <col width="27%" />
          <col width="*" />

          <thead>
            <tr align="left" valign="top">
              <th align="left" id="r1c1-t2" valign="bottom">Tool</th>

              <th align="left" id="r1c2-t2" valign="bottom">Description</th>
            </tr>
          </thead>

          <tbody>
            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r2c1-t2">
                <p><a id="sthref110"></a>Administration Console</p>
              </td>

              <td align="left" headers="r2c1-t2 r1c2-t2">
                <p>A web-based GUI GlassFish Server administration utility. Used to stop GlassFish Server and to manage users, resources, and applications.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r3c1-t2">
                <p><a id="sthref111"></a><code>asadmin</code></p>
              </td>

              <td align="left" headers="r3c1-t2 r1c2-t2">
                <p>A command-line GlassFish Server administration utility. Used to start and stop GlassFish Server and to manage users, resources, and applications.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r4c1-t2">
                <p><a id="sthref112"></a><code>appclient</code></p>
              </td>

              <td align="left" headers="r4c1-t2 r1c2-t2">
                <p>A command-line tool that launches the application client container and invokes the client application packaged in the application client JAR file.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r5c1-t2">
                <p><a id="sthref113"></a><code>capture-schema</code></p>
              </td>

              <td align="left" headers="r5c1-t2 r1c2-t2">
                <p>A command-line tool to extract schema information from a database, producing a schema file that GlassFish Server can use for container-managed persistence.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r6c1-t2">
                <p><a id="sthref114"></a><code>package-appclient</code></p>
              </td>

              <td align="left" headers="r6c1-t2 r1c2-t2">
                <p>A command-line tool to package the application client container libraries and JAR files.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r7c1-t2">
                <p><a id="sthref115"></a>Java DB database</p>
              </td>

              <td align="left" headers="r7c1-t2 r1c2-t2">
                <p>A copy of the Java DB server.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r8c1-t2">
                <p><a id="sthref116"></a><code>xjc</code></p>
              </td>

              <td align="left" headers="r8c1-t2 r1c2-t2">
                <p>A command-line tool to transform, or bind, a source XML schema to a set of JAXB content classes in the Java programming language.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r9c1-t2">
                <p><a id="sthref117"></a><code>schemagen</code></p>
              </td>

              <td align="left" headers="r9c1-t2 r1c2-t2">
                <p>A command-line tool to create a schema file for each namespace referenced in your Java classes.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r10c1-t2">
                <p><a id="sthref118"></a><code>wsimport</code></p>
              </td>

              <td align="left" headers="r10c1-t2 r1c2-t2">
                <p>A command-line tool to generate JAX-WS portable artifacts for a given WSDL file. After generation, these artifacts can be packaged in a WAR file with the WSDL and schema documents, along with the endpoint implementation, and then deployed.</p>
              </td>
            </tr>

            <tr align="left" valign="top">
              <td align="left" headers="r1c1-t2" id="r11c1-t2">
                <p><a id="sthref119"></a><code>wsgen</code></p>
              </td>

              <td align="left" headers="r11c1-t2 r1c2-t2">
                <p>A command-line tool to read a web service endpoint class and generate all the required JAX-WS portable artifacts for web service deployment and invocation.</p>
              </td>
            </tr>
          </tbody>
        </table><br />
      </div>
    </div>
  </div>
</body>
</html>
