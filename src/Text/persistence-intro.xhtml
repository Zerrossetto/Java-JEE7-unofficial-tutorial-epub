<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/javaee-darb.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="ind">
    <a id="BNBPZ"></a><a id="JEETT00095"></a>

    <h1 class="chapter"><span class="secnum">37</span> <a id="sthref1823"></a><a id="sthref1824"></a><a id="sthref1825"></a>Introduction to the Java Persistence API</h1>

    <p>The Java Persistence API provides Java developers with an object/relational mapping facility for managing relational data in Java applications. Java Persistence consists of four areas:</p>

    <ul>
      <li>
        <p>The Java Persistence API</p>
      </li>

      <li>
        <p>The query language</p>
      </li>

      <li>
        <p>The Java Persistence Criteria API</p>
      </li>

      <li>
        <p>Object/relational mapping metadata</p>
      </li>
    </ul>

    <p>The following topics are addressed here:</p>

    <ul>
      <li>
        <p><a href="../Text/persistence-intro.xhtml#BNBQA">Entities</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-intro.xhtml#BNBQN">Entity Inheritance</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-intro.xhtml#BNBQW">Managing Entities</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-intro.xhtml#GJISE">Querying Entities</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-intro.xhtml#CHDBEGIC">Database Schema Creation</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-intro.xhtml#GKCLC">Further Information about Persistence</a></p>
      </li>
    </ul>
  </div>

  <div class="ind">
    <a id="BNBQA"></a><a id="JEETT00488"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.1</span> <a id="sthref1826"></a><a id="sthref1827"></a>Entities</h1>

      <p>An entity is a lightweight persistence domain object. Typically, an entity represents a table in a relational database, and each entity instance corresponds to a row in that table. The primary programming artifact of an entity is the entity class, although entities can use helper classes.</p>

      <p>The persistent state of an entity is represented through either persistent fields or persistent properties. These fields or properties use object/relational mapping annotations to map the entities and entity relationships to the relational data in the underlying data store.</p><a id="BNBQB"></a><a id="JEETT01150"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.1</span> <a id="sthref1828"></a>Requirements for Entity Classes</h2>

        <p>An entity class must follow these requirements.</p>

        <ul>
          <li>
            <p><a id="sthref1829"></a>The class must be annotated with the <code>javax.persistence.Entity</code> annotation.</p>
          </li>

          <li>
            <p>The class must have a public or protected, no-argument constructor. The class may have other constructors.</p>
          </li>

          <li>
            <p>The class must not be declared <code>final</code>. No methods or persistent instance variables must be declared <code>final</code>.</p>
          </li>

          <li>
            <p>If an entity instance is passed by value as a detached object, such as through a session bean's remote business interface, the class must implement the <code>Serializable</code> interface.</p>
          </li>

          <li>
            <p>Entities may extend both entity and non-entity classes, and non-entity classes may extend entity classes.</p>
          </li>

          <li>
            <p>Persistent instance variables must be declared private, protected, or package-private and can be accessed directly only by the entity class's methods. Clients must access the entity's state through accessor or business methods.</p>
          </li>
        </ul>
      </div><a id="BNBQC"></a><a id="JEETT01151"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.2</span> <a id="sthref1830"></a><a id="sthref1831"></a>Persistent Fields and Properties in Entity Classes</h2>

        <p>The persistent state of an entity can be accessed through either the entity's instance variables or properties. The fields or properties must be of the following Java language types:</p>

        <ul>
          <li>
            <p>Java primitive types</p>
          </li>

          <li>
            <p><code>java.lang.String</code></p>
          </li>

          <li>
            <p>Other serializable types, including:</p>

            <ul>
              <li>
                <p>Wrappers of Java primitive types</p>
              </li>

              <li>
                <p><code>java.math.BigInteger</code></p>
              </li>

              <li>
                <p><code>java.math.BigDecimal</code></p>
              </li>

              <li>
                <p><code>java.util.Date</code></p>
              </li>

              <li>
                <p><code>java.util.Calendar</code></p>
              </li>

              <li>
                <p><code>java.sql.Date</code></p>
              </li>

              <li>
                <p><code>java.sql.Time</code></p>
              </li>

              <li>
                <p><code>java.sql.TimeStamp</code></p>
              </li>

              <li>
                <p>User-defined serializable types</p>
              </li>

              <li>
                <p><code>byte[]</code></p>
              </li>

              <li>
                <p><code>Byte[]</code></p>
              </li>

              <li>
                <p><code>char[]</code></p>
              </li>

              <li>
                <p><code>Character[]</code></p>
              </li>
            </ul>
          </li>

          <li>
            <p>Enumerated types</p>
          </li>

          <li>
            <p>Other entities and/or collections of entities</p>
          </li>

          <li>
            <p>Embeddable classes</p>
          </li>
        </ul>

        <p>Entities may use persistent fields, persistent properties, or a combination of both. If the mapping annotations are applied to the entity's instance variables, the entity uses persistent fields. If the mapping annotations are applied to the entity's getter methods for JavaBeans-style properties, the entity uses persistent properties.</p><a id="BNBQD"></a><a id="JEETT00669"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.2.1</span> <a id="sthref1832"></a>Persistent Fields</h3>

          <p>If the entity class uses persistent fields, the Persistence runtime accesses entity-class instance variables directly. All fields not annotated <code>javax.persistence.Transient</code> or not marked as Java <code>transient</code> will be persisted to the data store. The object/relational mapping annotations must be applied to the instance variables.</p>
        </div><a id="BNBQE"></a><a id="JEETT00670"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.2.2</span> <a id="sthref1833"></a>Persistent Properties</h3>

          <p>If the entity uses persistent properties, the entity must follow the method conventions of JavaBeans components. JavaBeans-style properties use getter and setter methods that are typically named after the entity class's instance variable names. For every persistent property <span class="variable">property</span> of type <span class="variable">Type</span> of the entity, there is a getter method <code>get</code><span class="variable">Property</span> and setter method <code>set</code><span class="variable">Property</span>. If the property is a Boolean, you may use <code>is</code><span class="variable">Property</span> instead of <code>get</code><span class="variable">Property</span>. For example, if a <code>Customer</code> entity uses persistent properties and has a private instance variable called <code>firstName</code>, the class defines a <code>getFirstName</code> and <code>setFirstName</code> method for retrieving and setting the state of the <code>firstName</code> instance variable.</p>

          <p>The method signatures for single-valued persistent properties are as follows:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">Type getProperty()
void setProperty(Type type)</pre>

          <p><a id="sthref1834"></a>The object/relational mapping annotations for persistent properties must be applied to the getter methods. Mapping annotations cannot be applied to fields or properties annotated <code>@Transient</code> or marked <code>transient</code>.</p>
        </div><a id="GIQVN"></a><a id="JEETT00671"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.2.3</span> <a id="sthref1835"></a><a id="sthref1836"></a>Using Collections in Entity Fields and Properties</h3>

          <p>Collection-valued persistent fields and properties must use the supported Java collection interfaces regardless of whether the entity uses persistent fields or properties. The following collection interfaces may be used:</p>

          <ul>
            <li>
              <p><code>java.util.Collection</code></p>
            </li>

            <li>
              <p><code>java.util.Set</code></p>
            </li>

            <li>
              <p><code>java.util.List</code></p>
            </li>

            <li>
              <p><code>java.util.Map</code></p>
            </li>
          </ul>

          <p>If the entity class uses persistent fields, the type in the preceding method signatures must be one of these collection types. Generic variants of these collection types may also be used. For example, if it has a persistent property that contains a set of phone numbers, the <code>Customer</code> entity would have the following methods:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">Set&lt;PhoneNumber&gt; getPhoneNumbers() { ... }
void setPhoneNumbers(Set&lt;PhoneNumber&gt;) { ... }</pre>

          <p>If a field or property of an entity consists of a collection of basic types or embeddable classes, use the <code>javax.persistence.ElementCollection</code> annotation on the field or property.</p>

          <p>The two attributes of <code>@ElementCollection</code> are <code>targetClass</code> and <code>fetch</code>. The <code>targetClass</code> attribute specifies the class name of the basic or embeddable class and is optional if the field or property is defined using Java programming language generics. The optional <code>fetch</code> attribute is used to specify whether the collection should be retrieved lazily or eagerly, using the <code>javax.persistence.FetchType</code> constants of either <code>LAZY</code> or <code>EAGER</code>, respectively. By default, the collection will be fetched lazily.</p>

          <p>The following entity, <code>Person</code>, has a persistent field, <code>nicknames</code>, which is a collection of <code>String</code> classes that will be fetched eagerly. The <code>targetClass</code> element is not required, because it uses generics to define the field:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Entity
public class Person {
    ...
    @ElementCollection(fetch=EAGER)
    protected Set&lt;String&gt; nickname = new HashSet();
    ...
}</pre>

          <p><a id="sthref1837"></a>Collections of entity elements and relationships may be represented by <code>java.util.Map</code> collections. A <code>Map</code> consists of a key and a value.</p>

          <p>When using <code>Map</code> elements or relationships, the following rules apply.</p>

          <ul>
            <li>
              <p>The <code>Map</code> key or value may be a basic Java programming language type, an embeddable class, or an entity.</p>
            </li>

            <li>
              <p>When the <code>Map</code> value is an embeddable class or basic type, use the <code>@ElementCollection</code> annotation.</p>
            </li>

            <li>
              <p>When the <code>Map</code> value is an entity, use the <code>@OneToMany</code> or <code>@ManyToMany</code> annotation.</p>
            </li>

            <li>
              <p>Use the <code>Map</code> type on only one side of a bidirectional relationship.</p>
            </li>
          </ul>

          <p>If the key type of a <code>Map</code> is a Java programming language basic type, use the annotation <code>javax.persistence.MapKeyColumn</code> to set the column mapping for the key. By default, the <code>name</code> attribute of <code>@MapKeyColumn</code> is of the form <span class="variable">RELATIONSHIP-FIELD/PROPERTY-NAME</span><code>_KEY</code>. For example, if the referencing relationship field name is <code>image</code>, the default <code>name</code> attribute is <code>IMAGE_KEY</code>.</p>

          <p>If the key type of a <code>Map</code> is an entity, use the <code>javax.persistence.MapKeyJoinColumn</code> annotation. If the multiple columns are needed to set the mapping, use the annotation <code>javax.persistence.MapKeyJoinColumns</code> to include multiple <code>@MapKeyJoinColumn</code> annotations. If no <code>@MapKeyJoinColumn</code> is present, the mapping column name is by default set to <span class="variable">RELATIONSHIP-FIELD/PROPERTY-NAME</span><code>_KEY</code>. For example, if the relationship field name is <code>employee</code>, the default <code>name</code> attribute is <code>EMPLOYEE_KEY</code>.</p>

          <p>If Java programming language generic types are not used in the relationship field or property, the key class must be explicitly set using the <code>javax.persistence.MapKeyClass</code> annotation.</p>

          <p>If the <code>Map</code> key is the primary key or a persistent field or property of the entity that is the <code>Map</code> value, use the <code>javax.persistence.MapKey</code> annotation. The <code>@MapKeyClass</code> and <code>@MapKey</code> annotations cannot be used on the same field or property.</p>

          <p>If the <code>Map</code> value is a Java programming language basic type or an embeddable class, it will be mapped as a collection table in the underlying database. If generic types are not used, the <code>@ElementCollection</code> annotation's <code>targetClass</code> attribute must be set to the type of the <code>Map</code> value.</p>

          <p>If the <code>Map</code> value is an entity and part of a many-to-many or one-to-many unidirectional relationship, it will be mapped as a join table in the underlying database. A unidirectional one-to-many relationship that uses a <code>Map</code> may also be mapped using the <code>@JoinColumn</code> annotation.</p>

          <p>If the entity is part of a one-to-many/many-to-one bidirectional relationship, it will be mapped in the table of the entity that represents the value of the <code>Map</code>. If generic types are not used, the <code>targetEntity</code> attribute of the <code>@OneToMany</code> and <code>@ManyToMany</code> annotations must be set to the type of the <code>Map</code> value.</p>
        </div><a id="GKAHQ"></a><a id="JEETT00672"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.2.4</span> <a id="sthref1838"></a><a id="sthref1839"></a><a id="sthref1840"></a>Validating Persistent Fields and Properties</h3>

          <p>The Java API for JavaBeans Validation (Bean Validation) provides a mechanism for validating application data. Bean Validation is integrated into the Java EE containers, allowing the same validation logic to be used in any of the tiers of an enterprise application.</p>

          <p>Bean Validation constraints may be applied to persistent entity classes, embeddable classes, and mapped superclasses. By default, the Persistence provider will automatically perform validation on entities with persistent fields or properties annotated with Bean Validation constraints immediately after the <code>PrePersist</code>, <code>PreUpdate</code>, and <code>PreRemove</code> lifecycle events.</p>

          <p>Bean Validation constraints are annotations applied to the fields or properties of Java programming language classes. Bean Validation provides a set of constraints as well as an API for defining custom constraints. Custom constraints can be specific combinations of the default constraints, or new constraints that don't use the default constraints. Each constraint is associated with at least one validator class that validates the value of the constrained field or property. Custom constraint developers must also provide a validator class for the constraint.</p>

          <p>Bean Validation constraints are applied to the persistent fields or properties of persistent classes. When adding Bean Validation constraints, use the same access strategy as the persistent class. That is, if the persistent class uses field access, apply the Bean Validation constraint annotations on the class's fields. If the class uses property access, apply the constraints on the getter methods.</p>

          <p><a href="../Text/persistence-intro.xhtml#GKAGK">Table 21-1</a> lists Bean Validation's built-in constraints, defined in the <code>javax.validation.constraints</code> package.</p>

          <p>All the built-in constraints listed in <a href="../Text/persistence-intro.xhtml#GKAGK">Table 21-1</a> have a corresponding annotation, <span class="variable">ConstraintName</span><code>.List</code>, for grouping multiple constraints of the same type on the same field or property. For example, the following persistent field has two <code>@Pattern</code> constraints:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Pattern.List({
    @Pattern(regexp="..."),
    @Pattern(regexp="...")
})</pre>

          <p>The following entity class, <code>Contact</code>, has Bean Validation constraints applied to its persistent fields:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Entity
public class Contact implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @NotNull
    protected String firstName;
    @NotNull
    protected String lastName;
    @Pattern(regexp = "[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\."
            + "[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@"
            + "(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9]"
            + "(?:[a-z0-9-]*[a-z0-9])?",
            message = "{invalid.email}")
    protected String email;
    @Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
            message = "{invalid.phonenumber}")
    protected String mobilePhone;
    @Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
            message = "{invalid.phonenumber}")
    protected String homePhone;
    @Temporal(javax.persistence.TemporalType.DATE)
    @Past
    protected Date birthday;
    ...
}</pre>

          <p>The <code>@NotNull</code> annotation on the <code>firstName</code> and <code>lastName</code> fields specifies that those fields are now required. If a new <code>Contact</code> instance is created where <code>firstName</code> or <code>lastName</code> have not been initialized, Bean Validation will throw a validation error. Similarly, if a previously created instance of <code>Contact</code> has been modified so that <code>firstName</code> or <code>lastName</code> are null, a validation error will be thrown.</p>

          <p>The <code>email</code> field has a <code>@Pattern</code> constraint applied to it, with a complicated regular expression that matches most valid email addresses. If the value of <code>email</code> doesn't match this regular expression, a validation error will be thrown.</p>

          <p>The <code>homePhone</code> and <code>mobilePhone</code> fields have the same <code>@Pattern</code> constraints. The regular expression matches 10 digit telephone numbers in the United States and Canada of the form <code>(</code><span class="variable">xxx</span><code>)</code> <span class="variable">xxx</span><code>-</code><span class="variable">xxxx</span>.</p>

          <p>The <code>birthday</code> field is annotated with the <code>@Past</code> constraint, which ensures that the value of <code>birthday</code> must be in the past.</p>
        </div>
      </div><a id="BNBQF"></a><a id="JEETT01152"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.3</span> <a id="sthref1841"></a><a id="sthref1842"></a><a id="sthref1843"></a>Primary Keys in Entities</h2>

        <p>Each entity has a unique object identifier. A customer entity, for example, might be identified by a customer number. The unique identifier, or <span class="glossaryterm">primary key</span>, enables clients to locate a particular entity instance. Every entity must have a primary key. An entity may have either a simple or a composite primary key.</p>

        <p><a id="sthref1844"></a>Simple primary keys use the <code>javax.persistence.Id</code> annotation to denote the primary key property or field.</p>

        <p><a id="sthref1845"></a><a id="sthref1846"></a>Composite primary keys are used when a primary key consists of more than one attribute, which corresponds to a set of single persistent properties or fields. Composite primary keys must be defined in a primary key class. Composite primary keys are denoted using the <code>javax.persistence.EmbeddedId</code> and <code>javax.persistence.IdClass</code> annotations.</p>

        <p>The primary key, or the property or field of a composite primary key, must be one of the following Java language types:</p>

        <ul>
          <li>
            <p>Java primitive types</p>
          </li>

          <li>
            <p>Java primitive wrapper types</p>
          </li>

          <li>
            <p><code>java.lang.String</code></p>
          </li>

          <li>
            <p><code>java.util.Date</code> (the temporal type should be <code>DATE</code>)</p>
          </li>

          <li>
            <p><code>java.sql.Date</code></p>
          </li>

          <li>
            <p><code>java.math.BigDecimal</code></p>
          </li>

          <li>
            <p><code>java.math.BigInteger</code></p>
          </li>
        </ul>

        <p>Floating-point types should never be used in primary keys. If you use a generated primary key, only integral types will be portable.</p>

        <p>A primary key class must meet these requirements.</p>

        <ul>
          <li>
            <p>The access control modifier of the class must be <code>public</code>.</p>
          </li>

          <li>
            <p>The properties of the primary key class must be <code>public</code> or <code>protected</code> if property-based access is used.</p>
          </li>

          <li>
            <p>The class must have a public default constructor.</p>
          </li>

          <li>
            <p><a id="sthref1847"></a><a id="sthref1848"></a>The class must implement the <code>hashCode()</code> and <code>equals(Object other)</code> methods.</p>
          </li>

          <li>
            <p>The class must be serializable.</p>
          </li>

          <li>
            <p>A composite primary key must be represented and mapped to multiple fields or properties of the entity class or must be represented and mapped as an embeddable class.</p>
          </li>

          <li>
            <p>If the class is mapped to multiple fields or properties of the entity class, the names and types of the primary key fields or properties in the primary key class must match those of the entity class.</p>
          </li>
        </ul>

        <p><a id="sthref1849"></a><a id="sthref1850"></a>The following primary key class is a composite key, and the <code>customerOrder</code> and <code>itemId</code> fields together uniquely identify an entity:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">public final class LineItemKey implements Serializable {
    private Integer customerOrder;
    private int itemId;

    public LineItemKey() {}

    public LineItemKey(Integer order, int itemId) {
        this.setCustomerOrder(order);
        this.setItemId(itemId);
    }

    @Override
    public int hashCode() {
        return ((this.getCustomerOrder() == null
                ? 0 : this.getCustomerOrder().hashCode())
                ^ ((int) this.getItemId()));
    }

    @Override
    public boolean equals(Object otherOb) {
        if (this == otherOb) {
            return true;
        }
        if (!(otherOb instanceof LineItemKey)) {
            return false;
        }
        LineItemKey other = (LineItemKey) otherOb;
        return ((this.getCustomerOrder() == null
                ? other.getCustomerOrder() == null : this.getCustomerOrder()
                .equals(other.getCustomerOrder()))
                &amp;&amp; (this.getItemId() == other.getItemId()));
    }

    @Override
    public String toString() {
        return "" + getCustomerOrder() + "-" + getItemId();
    }
    /* Getters and setters */
}</pre>
      </div><a id="BNBQH"></a><a id="JEETT01153"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.4</span> <a id="sthref1851"></a>Multiplicity in Entity Relationships</h2>

        <p>Multiplicities are of the following types.</p>

        <ul>
          <li>
            <p><a id="sthref1852"></a><a id="sthref1853"></a><span class="glossaryterm">One-to-one</span>: Each entity instance is related to a single instance of another entity. For example, to model a physical warehouse in which each storage bin contains a single widget, <code>StorageBin</code> and <code>Widget</code> would have a one-to-one relationship. One-to-one relationships use the <code>javax.persistence.OneToOne</code> annotation on the corresponding persistent property or field.</p>
          </li>

          <li>
            <p><a id="sthref1854"></a><a id="sthref1855"></a><span class="glossaryterm">One-to-many</span>: An entity instance can be related to multiple instances of the other entities. A sales order, for example, can have multiple line items. In the order application, <code>CustomerOrder</code> would have a one-to-many relationship with <code>LineItem</code>. One-to-many relationships use the <code>javax.persistence.OneToMany</code> annotation on the corresponding persistent property or field.</p>
          </li>

          <li>
            <p><a id="sthref1856"></a><a id="sthref1857"></a><span class="glossaryterm">Many-to-one</span>: Multiple instances of an entity can be related to a single instance of the other entity. This multiplicity is the opposite of a one-to-many relationship. In the example just mentioned, the relationship to <code>CustomerOrder</code> from the perspective of <code>LineItem</code> is many-to-one. Many-to-one relationships use the <code>javax.persistence.ManyToOne</code> annotation on the corresponding persistent property or field.</p>
          </li>

          <li>
            <p><a id="sthref1858"></a><a id="sthref1859"></a><span class="glossaryterm">Many-to-many</span>: The entity instances can be related to multiple instances of each other. For example, each college course has many students, and every student may take several courses. Therefore, in an enrollment application, <code>Course</code> and <code>Student</code> would have a many-to-many relationship. Many-to-many relationships use the <code>javax.persistence.ManyToMany</code> annotation on the corresponding persistent property or field.</p>
          </li>
        </ul>
      </div><a id="BNBQI"></a><a id="JEETT01154"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.5</span> <a id="sthref1860"></a>Direction in Entity Relationships</h2>

        <p>The direction of a relationship can be either bidirectional or unidirectional. A bidirectional relationship has both an owning side and an inverse side. A unidirectional relationship has only an owning side. The owning side of a relationship determines how the Persistence runtime makes updates to the relationship in the database.</p><a id="BNBQJ"></a><a id="JEETT00673"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.5.1</span> <a id="sthref1861"></a>Bidirectional Relationships</h3>

          <p>In a <span class="glossaryterm">bidirectional</span> relationship, each entity has a relationship field or property that refers to the other entity. Through the relationship field or property, an entity class's code can access its related object. If an entity has a related field, the entity is said to "know" about its related object. For example, if <code>CustomerOrder</code> knows what <code>LineItem</code> instances it has and if <code>LineItem</code> knows what <code>CustomerOrder</code> it belongs to, they have a bidirectional relationship.</p>

          <p>Bidirectional relationships must follow these rules.</p>

          <ul>
            <li>
              <p><a id="sthref1862"></a><a id="sthref1863"></a><a id="sthref1864"></a>The inverse side of a bidirectional relationship must refer to its owning side by using the <code>mappedBy</code> element of the <code>@OneToOne</code>, <code>@OneToMany</code>, or <code>@ManyToMany</code> annotation. The <code>mappedBy</code> element designates the property or field in the entity that is the owner of the relationship.</p>
            </li>

            <li>
              <p>The many side of many-to-one bidirectional relationships must not define the <code>mappedBy</code> element. The many side is always the owning side of the relationship.</p>
            </li>

            <li>
              <p>For one-to-one bidirectional relationships, the owning side corresponds to the side that contains the corresponding foreign key.</p>
            </li>

            <li>
              <p>For many-to-many bidirectional relationships, either side may be the owning side.</p>
            </li>
          </ul>
        </div><a id="BNBQK"></a><a id="JEETT00674"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.5.2</span> <a id="sthref1865"></a>Unidirectional Relationships</h3>

          <p>In a <span class="glossaryterm">unidirectional</span> relationship, only one entity has a relationship field or property that refers to the other. For example, <code>LineItem</code> would have a relationship field that identifies <code>Product</code>, but <code>Product</code> would not have a relationship field or property for <code>LineItem</code>. In other words, <code>LineItem</code> knows about <code>Product</code>, but <code>Product</code> doesn't know which <code>LineItem</code> instances refer to it.</p>
        </div><a id="BNBQL"></a><a id="JEETT00675"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.5.3</span> Queries and Relationship Direction</h3>

          <p><a id="sthref1866"></a><a id="sthref1867"></a>Java Persistence query language and Criteria API queries often navigate across relationships. The direction of a relationship determines whether a query can navigate from one entity to another. For example, a query can navigate from <code>LineItem</code> to <code>Product</code> but cannot navigate in the opposite direction. For <code>CustomerOrder</code> and <code>LineItem</code>, a query could navigate in both directions because these two entities have a bidirectional relationship.</p>
        </div><a id="BNBQM"></a><a id="JEETT00676"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.5.4</span> <a id="sthref1868"></a>Cascade Operations and Relationships</h3>

          <p>Entities that use relationships often have dependencies on the existence of the other entity in the relationship. For example, a line item is part of an order; if the order is deleted, the line item also should be deleted. This is called a cascade delete relationship.</p>

          <p>The <code>javax.persistence.CascadeType</code> enumerated type defines the cascade operations that are applied in the <code>cascade</code> element of the relationship annotations. <a href="../Text/persistence-intro.xhtml#GJJNJ">Table 37-1</a> lists the cascade operations for entities.</p>

          <div class="tblhruleformal">
            <a id="sthref1869"></a><a id="GJJNJ"></a>

            <p class="titleintable">Table 37-1 Cascade Operations for Entities</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and describes the cascade operations available for entities." title="Cascade Operations for Entities" width="100%">
              <col width="18%" />
              <col width="*" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t2" valign="bottom">Cascade Operation</th>

                  <th align="left" id="r1c2-t2" valign="bottom">Description</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r2c1-t2">
                    <p><code>ALL</code></p>
                  </td>

                  <td align="left" headers="r2c1-t2 r1c2-t2">
                    <p>All cascade operations will be applied to the parent entity's related entity. <code>All</code> is equivalent to specifying <code>cascade={DETACH, MERGE, PERSIST, REFRESH, REMOVE}</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r3c1-t2">
                    <p><code>DETACH</code></p>
                  </td>

                  <td align="left" headers="r3c1-t2 r1c2-t2">
                    <p>If the parent entity is detached from the persistence context, the related entity will also be detached.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r4c1-t2">
                    <p><code>MERGE</code></p>
                  </td>

                  <td align="left" headers="r4c1-t2 r1c2-t2">
                    <p>If the parent entity is merged into the persistence context, the related entity will also be merged.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r5c1-t2">
                    <p><code>PERSIST</code></p>
                  </td>

                  <td align="left" headers="r5c1-t2 r1c2-t2">
                    <p>If the parent entity is persisted into the persistence context, the related entity will also be persisted.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r6c1-t2">
                    <p><code>REFRESH</code></p>
                  </td>

                  <td align="left" headers="r6c1-t2 r1c2-t2">
                    <p>If the parent entity is refreshed in the current persistence context, the related entity will also be refreshed.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t2" id="r7c1-t2">
                    <p><code>REMOVE</code></p>
                  </td>

                  <td align="left" headers="r7c1-t2 r1c2-t2">
                    <p>If the parent entity is removed from the current persistence context, the related entity will also be removed.</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <p><a id="sthref1870"></a><a id="sthref1871"></a>Cascade delete relationships are specified using the <code>cascade=REMOVE</code> element specification for <code>@OneToOne</code> and <code>@OneToMany</code> relationships. For example:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@OneToMany(cascade=REMOVE, mappedBy="customer")public SetCustomerOrder getOrders() { return orders; }</pre>
        </div><a id="GIQXY"></a><a id="JEETT00677"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.1.5.5</span> <a id="sthref1872"></a>Orphan Removal in Relationships</h3>

          <p>When a target entity in a one-to-one or one-to-many relationship is removed from the relationship, it is often desirable to cascade the remove operation to the target entity. Such target entities are considered "orphans," and the <code>orphanRemoval</code> attribute can be used to specify that orphaned entities should be removed. For example, if an order has many line items and one of them is removed from the order, the removed line item is considered an orphan. If <code>orphanRemoval</code> is set to <code>true</code>, the line item entity will be deleted when the line item is removed from the order.</p>

          <p>The <code>orphanRemoval</code> attribute in <code>@OneToMany</code> and <code>@oneToOne</code> takes a Boolean value and is by default false.</p>

          <p>The following example will cascade the remove operation to the orphaned <code>order</code> entity when the <code>customer</code> entity is deleted:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@OneToMany(mappedBy="customer", orphanRemoval="true")
public List&lt;CustomerOrder&gt; getOrders() { ... }</pre>
        </div>
      </div><a id="GJIWZ"></a><a id="JEETT01155"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.1.6</span> <a id="sthref1873"></a><a id="sthref1874"></a><a id="sthref1875"></a>Embeddable Classes in Entities</h2>

        <p>Embeddable classes are used to represent the state of an entity but don't have a persistent identity of their own, unlike entity classes. Instances of an embeddable class share the identity of the entity that owns it. Embeddable classes exist only as the state of another entity. An entity may have single-valued or collection-valued embeddable class attributes.</p>

        <p>Embeddable classes have the same rules as entity classes but are annotated with the <code>javax.persistence.Embeddable</code> annotation instead of <code>@Entity</code>.</p>

        <p>The following embeddable class, <code>ZipCode</code>, has the fields <code>zip</code> and <code>plusFour</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Embeddable
public class ZipCode {
    String zip;
    String plusFour;
    ...
}</pre>

        <p>This embeddable class is used by the <code>Address</code> entity:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Entity
public class Address {
    @Id
    protected long id
    String street1;
    String street2;
    String city;
    String province;
    @Embedded
    ZipCode zipCode;
    String country;
    ...
}</pre>

        <p>Entities that own embeddable classes as part of their persistent state may annotate the field or property with the <code>javax.persistence.Embedded</code> annotation but are not required to do so.</p>

        <p>Embeddable classes may themselves use other embeddable classes to represent their state. They may also contain collections of basic Java programming language types or other embeddable classes. Embeddable classes may also contain relationships to other entities or collections of entities. If the embeddable class has such a relationship, the relationship is from the target entity or collection of entities to the entity that owns the embeddable class.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNBQN"></a><a id="JEETT00489"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.2</span> <a id="sthref1876"></a>Entity Inheritance</h1>

      <p>Entities support class inheritance, polymorphic associations, and polymorphic queries. Entity classes can extend non-entity classes, and non-entity classes can extend entity classes. Entity classes can be both abstract and concrete.</p>

      <p>The <code>roster</code> example application demonstrates entity inheritance, as described in <a href="../Text/persistence-intro.xhtml#GIQRF">Entity Inheritance in the roster Application</a>.</p><a id="BNBQO"></a><a id="JEETT01157"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.2.1</span> <a id="sthref1877"></a>Abstract Entities</h2>

        <p>An abstract class may be declared an entity by decorating the class with <code>@Entity</code>. Abstract entities are like concrete entities but cannot be instantiated.</p>

        <p>Abstract entities can be queried just like concrete entities. If an abstract entity is the target of a query, the query operates on all the concrete subclasses of the abstract entity:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Entity
public abstract class Employee {
    @Id
    protected Integer employeeId;
    ...
}
@Entity
public class FullTimeEmployee extends Employee {
    protected Integer salary;
    ...
}
@Entity
public class PartTimeEmployee extends Employee {
    protected Float hourlyWage;
}</pre>
      </div><a id="BNBQP"></a><a id="JEETT01158"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.2.2</span> <a id="sthref1878"></a>Mapped Superclasses</h2>

        <p>Entities may inherit from superclasses that contain persistent state and mapping information but are not entities. That is, the superclass is not decorated with the <code>@Entity</code> annotation and is not mapped as an entity by the Java Persistence provider. These superclasses are most often used when you have state and mapping information common to multiple entity classes.</p>

        <p>Mapped superclasses are specified by decorating the class with the annotation <code>javax.persistence.MappedSuperclass</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@MappedSuperclass
public class Employee {
    @Id
    protected Integer employeeId;
    ...
}
@Entity
public class FullTimeEmployee extends Employee {
    protected Integer salary;
    ...
}
@Entity
public class PartTimeEmployee extends Employee {
    protected Float hourlyWage;
    ...
}<br /></pre>

        <p>Mapped superclasses cannot be queried and cannot be used in <code>EntityManager</code> or <code>Query</code> operations. You must use entity subclasses of the mapped superclass in <code>EntityManager</code> or <code>Query</code> operations. Mapped superclasses can't be targets of entity relationships. Mapped superclasses can be abstract or concrete.</p>

        <p>Mapped superclasses do not have any corresponding tables in the underlying datastore. Entities that inherit from the mapped superclass define the table mappings. For instance, in the preceding code sample, the underlying tables would be <code>FULLTIMEEMPLOYEE</code> and <code>PARTTIMEEMPLOYEE</code>, but there is no <code>EMPLOYEE</code> table.</p>
      </div><a id="BNBQQ"></a><a id="JEETT01159"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.2.3</span> <a id="sthref1879"></a>Non-Entity Superclasses</h2>

        <p>Entities may have non-entity superclasses, and these superclasses can be either abstract or concrete. The state of non-entity superclasses is nonpersistent, and any state inherited from the non-entity superclass by an entity class is nonpersistent. Non-entity superclasses may not be used in <code>EntityManager</code> or <code>Query</code> operations. Any mapping or relationship annotations in non-entity superclasses are ignored.</p>
      </div><a id="BNBQR"></a><a id="JEETT01160"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.2.4</span> <a id="sthref1880"></a>Entity Inheritance Mapping Strategies</h2>

        <p>You can configure how the Java Persistence provider maps inherited entities to the underlying datastore by decorating the root class of the hierarchy with the annotation <code>javax.persistence.Inheritance</code>. The following mapping strategies are used to map the entity data to the underlying database:</p>

        <ul>
          <li>
            <p>A single table per class hierarchy</p>
          </li>

          <li>
            <p>A table per concrete entity class</p>
          </li>

          <li>
            <p>A "join" strategy, whereby fields or properties that are specific to a subclass are mapped to a different table than the fields or properties that are common to the parent class</p>
          </li>
        </ul>

        <p>The strategy is configured by setting the <code>strategy</code> element of <code>@Inheritance</code> to one of the options defined in the <code>javax.persistence.InheritanceType</code> enumerated type:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">public enum InheritanceType {
    SINGLE_TABLE,
    JOINED,
    TABLE_PER_CLASS
};</pre>

        <p>The default strategy, <code>InheritanceType.SINGLE_TABLE</code>, is used if the <code>@Inheritance</code> annotation is not specified on the root class of the entity hierarchy.</p><a id="BNBQS"></a><a id="JEETT00679"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.2.4.1</span> <a id="sthref1881"></a><a id="sthref1882"></a>The Single Table per Class Hierarchy Strategy</h3>

          <p><a id="sthref1883"></a>With this strategy, which corresponds to the default <code>InheritanceType.SINGLE_TABLE</code>, all classes in the hierarchy are mapped to a single table in the database. This table has a <span class="glossaryterm">discriminator column</span> containing a value that identifies the subclass to which the instance represented by the row belongs.</p>

          <p>The discriminator column, whose elements are shown in <a href="../Text/persistence-intro.xhtml#BNBQT">Table 37-2</a>, can be specified by using the <code>javax.persistence.DiscriminatorColumn</code> annotation on the root of the entity class hierarchy.</p>

          <div class="tblhruleformal">
            <a id="sthref1884"></a><a id="BNBQT"></a>

            <p class="titleintable">Table 37-2 @DiscriminatorColumn Elements</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and describes the types and names of DiscriminatorColumn elements." title="@DiscriminatorColumn Elements" width="100%">
              <col width="23%" />
              <col width="22%" />
              <col width="*" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t3" valign="bottom">Type</th>

                  <th align="left" id="r1c2-t3" valign="bottom">Name</th>

                  <th align="left" id="r1c3-t3" valign="bottom">Description</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r2c1-t3">
                    <p><code>String</code></p>
                  </td>

                  <td align="left" headers="r2c1-t3 r1c2-t3">
                    <p><code>name</code></p>
                  </td>

                  <td align="left" headers="r2c1-t3 r1c3-t3">
                    <p>The name of the column to be used as the discriminator column. The default is <code>DTYPE</code>. This element is optional.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r3c1-t3">
                    <p><code>DiscriminatorType</code></p>
                  </td>

                  <td align="left" headers="r3c1-t3 r1c2-t3">
                    <p><code>discriminatorType</code></p>
                  </td>

                  <td align="left" headers="r3c1-t3 r1c3-t3">
                    <p>The type of the column to be used as a discriminator column. The default is <code>DiscriminatorType.STRING</code>. This element is optional.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r4c1-t3">
                    <p><code>String</code></p>
                  </td>

                  <td align="left" headers="r4c1-t3 r1c2-t3">
                    <p><code>columnDefinition</code></p>
                  </td>

                  <td align="left" headers="r4c1-t3 r1c3-t3">
                    <p>The SQL fragment to use when creating the discriminator column. The default is generated by the Persistence provider and is implementation-specific. This element is optional.</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r5c1-t3">
                    <p><code>String</code></p>
                  </td>

                  <td align="left" headers="r5c1-t3 r1c2-t3">
                    <p><code>length</code></p>
                  </td>

                  <td align="left" headers="r5c1-t3 r1c3-t3">
                    <p>The column length for <code>String</code>-based discriminator types. This element is ignored for non-<code>String</code> discriminator types. The default is 31. This element is optional.</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <p>The <code>javax.persistence.DiscriminatorType</code> enumerated type is used to set the type of the discriminator column in the database by setting the <code>discriminatorType</code> element of <code>@DiscriminatorColumn</code> to one of the defined types. <code>DiscriminatorType</code> is defined as follows:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">public enum DiscriminatorType {
    STRING,
    CHAR,
    INTEGER
}</pre>

          <p>If <code>@DiscriminatorColumn</code> is not specified on the root of the entity hierarchy and a discriminator column is required, the Persistence provider assumes a default column name of <code>DTYPE</code> and column type of <code>DiscriminatorType.STRING</code>.</p>

          <p>The <code>javax.persistence.DiscriminatorValue</code> annotation may be used to set the value entered into the discriminator column for each entity in a class hierarchy. You may decorate only concrete entity classes with <code>@DiscriminatorValue</code>.</p>

          <p>If <code>@DiscriminatorValue</code> is not specified on an entity in a class hierarchy that uses a discriminator column, the Persistence provider will provide a default, implementation-specific value. If the <code>discriminatorType</code> element of <code>@DiscriminatorColumn</code> is <code>DiscriminatorType.STRING</code>, the default value is the name of the entity.</p>

          <p>This strategy provides good support for polymorphic relationships between entities and queries that cover the entire entity class hierarchy. However, this strategy requires the columns that contain the state of subclasses to be nullable.</p>
        </div><a id="BNBQU"></a><a id="JEETT00680"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.2.4.2</span> The Table per Concrete Class Strategy</h3>

          <p>In this strategy, which corresponds to <code>InheritanceType.TABLE_PER_CLASS</code>, each concrete class is mapped to a separate table in the database. All fields or properties in the class, including inherited fields or properties, are mapped to columns in the class's table in the database.</p>

          <p>This strategy provides poor support for polymorphic relationships and usually requires either SQL <code>UNION</code> queries or separate SQL queries for each subclass for queries that cover the entire entity class hierarchy.</p>

          <p>Support for this strategy is optional and may not be supported by all Java Persistence API providers. The default Java Persistence API provider in GlassFish Server does not support this strategy.</p>
        </div><a id="BNBQV"></a><a id="JEETT00681"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.2.4.3</span> The Joined Subclass Strategy</h3>

          <p>In this strategy, which corresponds to <code>InheritanceType.JOINED</code>, the root of the class hierarchy is represented by a single table, and each subclass has a separate table that contains only those fields specific to that subclass. That is, the subclass table does not contain columns for inherited fields or properties. The subclass table also has a column or columns that represent its primary key, which is a foreign key to the primary key of the superclass table.</p>

          <p>This strategy provides good support for polymorphic relationships but requires one or more join operations to be performed when instantiating entity subclasses. This may result in poor performance for extensive class hierarchies. Similarly, queries that cover the entire class hierarchy require join operations between the subclass tables, resulting in decreased performance.</p>

          <p>Some Java Persistence API providers, including the default provider in GlassFish Server, require a discriminator column that corresponds to the root entity when using the joined subclass strategy. If you are not using automatic table creation in your application, make sure that the database table is set up correctly for the discriminator column defaults, or use the <code>@DiscriminatorColumn</code> annotation to match your database schema. For information on discriminator columns, see <a href="../Text/persistence-intro.xhtml#BNBQS">The Single Table per Class Hierarchy Strategy</a>.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNBQW"></a><a id="JEETT00490"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.3</span> <a id="sthref1885"></a><a id="sthref1886"></a>Managing Entities</h1>

      <p>Entities are managed by the entity manager, which is represented by <code>javax.persistence.EntityManager</code> instances. Each <code>EntityManager</code> instance is associated with a persistence context: a set of managed entity instances that exist in a particular data store. A persistence context defines the scope under which particular entity instances are created, persisted, and removed. The <code>EntityManager</code> interface defines the methods that are used to interact with the persistence context.</p><a id="BNBQY"></a><a id="JEETT01161"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.3.1</span> <a id="sthref1887"></a><a id="sthref1888"></a>The EntityManager Interface</h2>

        <p>The <code>EntityManager</code> API creates and removes persistent entity instances, finds entities by the entity's primary key, and allows queries to be run on entities.</p><a id="BNBQZ"></a><a id="JEETT00682"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.1</span> <a id="sthref1889"></a>Container-Managed Entity Managers</h3>

          <p>With a <span class="glossaryterm">container-managed entity manager</span>, an <code>EntityManager</code> instance's persistence context is automatically propagated by the container to all application components that use the <code>EntityManager</code> instance within a single Java Transaction API (JTA) transaction.</p>

          <p><a id="sthref1890"></a>JTA transactions usually involve calls across application components. To complete a JTA transaction, these components usually need access to a single persistence context. This occurs when an <code>EntityManager</code> is injected into the application components by means of the <code>javax.persistence.PersistenceContext</code> annotation. The persistence context is automatically propagated with the current JTA transaction, and <code>EntityManager</code> references that are mapped to the same persistence unit provide access to the persistence context within that transaction. By automatically propagating the persistence context, application components don't need to pass references to <code>EntityManager</code> instances to each other in order to make changes within a single transaction. The Java EE container manages the lifecycle of container-managed entity managers.</p>

          <p>To obtain an <code>EntityManager</code> instance, inject the entity manager into the application component:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PersistenceContext
EntityManager em;</pre>
        </div><a id="BNBRA"></a><a id="JEETT00683"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.2</span> <a id="sthref1891"></a><a id="sthref1892"></a>Application-Managed Entity Managers</h3>

          <p>With an <span class="glossaryterm">application-managed entity manager</span>, on the other hand, the persistence context is not propagated to application components, and the lifecycle of <code>EntityManager</code> instances is managed by the application.</p>

          <p>Application-managed entity managers are used when applications need to access a persistence context that is not propagated with the JTA transaction across <code>EntityManager</code> instances in a particular persistence unit. In this case, each <code>EntityManager</code> creates a new, isolated persistence context. The <code>EntityManager</code> and its associated persistence context are created and destroyed explicitly by the application. They are also used when directly injecting <code>EntityManager</code> instances can't be done because <code>EntityManager</code> instances are not thread-safe. <code>EntityManagerFactory</code> instances are thread-safe.</p>

          <p>Applications create <code>EntityManager</code> instances in this case by using the <code>createEntityManager</code> method of <code>javax.persistence.EntityManagerFactory</code>.</p>

          <p><a id="sthref1893"></a>To obtain an <code>EntityManager</code> instance, you first must obtain an <code>EntityManagerFactory</code> instance by injecting it into the application component by means of the <code>javax.persistence.PersistenceUnit</code> annotation:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PersistenceUnit
EntityManagerFactory emf;</pre>

          <p>Then obtain an <code>EntityManager</code> from the <code>EntityManagerFactory</code> instance:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">EntityManager em = emf.createEntityManager();</pre>

          <p><a id="sthref1894"></a>Application-managed entity managers don't automatically propagate the JTA transaction context. Such applications need to manually gain access to the JTA transaction manager and add transaction demarcation information when performing entity operations. The <code>javax.transaction.UserTransaction</code> interface defines methods to begin, commit, and roll back transactions. Inject an instance of <code>UserTransaction</code> by creating an instance variable annotated with <code>@Resource</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@Resource
UserTransaction utx;</pre>

          <p>To begin a transaction, call the <code>UserTransaction.begin</code> method. When all the entity operations are complete, call the <code>UserTransaction.commit</code> method to commit the transaction. The <code>UserTransaction.rollback</code> method is used to roll back the current transaction.</p>

          <p>The following example shows how to manage transactions in an application that uses an application-managed entity manager:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PersistenceUnit
EntityManagerFactory emf;
EntityManager em;
@Resource
UserTransaction utx;
...
em = emf.createEntityManager();
try {
    utx.begin();
    em.persist(SomeEntity);
    em.merge(AnotherEntity);
    em.remove(ThirdEntity);
    utx.commit();
} catch (Exception e) {
    utx.rollback();
}</pre>
        </div><a id="BNBRB"></a><a id="JEETT00684"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.3</span> <a id="sthref1895"></a>Finding Entities Using the EntityManager</h3>

          <p>The <code>EntityManager.find</code> method is used to look up entities in the data store by the entity's primary key:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PersistenceContext
EntityManager em;
public void enterOrder(int custID, CustomerOrder newOrder) {
    Customer cust = em.find(Customer.class, custID);
    cust.getOrders().add(newOrder);
    newOrder.setCustomer(cust);
}</pre>
        </div><a id="BNBRC"></a><a id="JEETT00685"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.4</span> <a id="sthref1896"></a>Managing an Entity Instance's Lifecycle</h3>

          <p>You manage entity instances by invoking operations on the entity by means of an <code>EntityManager</code> instance. Entity instances are in one of four states: new, managed, detached, or removed.</p>

          <ul>
            <li>
              <p>New entity instances have no persistent identity and are not yet associated with a persistence context.</p>
            </li>

            <li>
              <p>Managed entity instances have a persistent identity and are associated with a persistence context.</p>
            </li>

            <li>
              <p>Detached entity instances have a persistent identity and are not currently associated with a persistence context.</p>
            </li>

            <li>
              <p>Removed entity instances have a persistent identity, are associated with a persistent context, and are scheduled for removal from the data store.</p>
            </li>
          </ul>
        </div><a id="BNBRD"></a><a id="JEETT00686"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.5</span> <a id="sthref1897"></a>Persisting Entity Instances</h3>

          <p>New entity instances become managed and persistent either by invoking the <code>persist</code> method or by a cascading <code>persist</code> operation invoked from related entities that have the <code>cascade=PERSIST</code> or <code>cascade=ALL</code> elements set in the relationship annotation. This means that the entity's data is stored to the database when the transaction associated with the <code>persist</code> operation is completed. If the entity is already managed, the <code>persist</code> operation is ignored, although the <code>persist</code> operation will cascade to related entities that have the <code>cascade</code> element set to <code>PERSIST</code> or <code>ALL</code> in the relationship annotation. If <code>persist</code> is called on a removed entity instance, the entity becomes managed. If the entity is detached, either <code>persist</code> will throw an <code>IllegalArgumentException</code>, or the transaction commit will fail. The following method performs a <code>persist</code> operation:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@PersistenceContext
EntityManager em;
...
public LineItem createLineItem(CustomerOrder order, Product product,
        int quantity) {
    LineItem li = new LineItem(order, product, quantity);
    order.getLineItems().add(li);
    em.persist(li);
    return li;
}</pre>

          <p>The <code>persist</code> operation is propagated to all entities related to the calling entity that have the <code>cascade</code> element set to <code>ALL</code> or <code>PERSIST</code> in the relationship annotation:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">@OneToMany(cascade=ALL, mappedBy="order")
public Collection&lt;LineItem&gt; getLineItems() {
    return lineItems;
}</pre>
        </div><a id="BNBRE"></a><a id="JEETT00687"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.6</span> <a id="sthref1898"></a>Removing Entity Instances</h3>

          <p>Managed entity instances are removed by invoking the <code>remove</code> method or by a cascading <code>remove</code> operation invoked from related entities that have the <code>cascade=REMOVE</code> or <code>cascade=ALL</code> elements set in the relationship annotation. If the <code>remove</code> method is invoked on a new entity, the <code>remove</code> operation is ignored, although <code>remove</code> will cascade to related entities that have the <code>cascade</code> element set to <code>REMOVE</code> or <code>ALL</code> in the relationship annotation. If <code>remove</code> is invoked on a detached entity, either <code>remove</code> will throw an <code>IllegalArgumentException</code>, or the transaction commit will fail. If invoked on an already removed entity, <code>remove</code> will be ignored. The entity's data will be removed from the data store when the transaction is completed or as a result of the <code>flush</code> operation.</p>

          <p>In the following example, all <code>LineItem</code> entities associated with the order are also removed, as <code>CustomerOrder.getLineItems</code> has <code>cascade=ALL</code> set in the relationship annotation:</p>
          <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">public void removeOrder(Integer orderId) {
    try {
        CustomerOrder order = em.find(CustomerOrder.class, orderId);
        em.remove(order);
    }...</pre>
        </div><a id="BNBRF"></a><a id="JEETT00688"></a>

        <div class="sect3">
          <h3 class="sect3"><span class="secnum">37.3.1.7</span> <a id="sthref1899"></a>Synchronizing Entity Data to the Database</h3>

          <p>The state of persistent entities is synchronized to the database when the transaction with which the entity is associated commits. If a managed entity is in a bidirectional relationship with another managed entity, the data will be persisted, based on the owning side of the relationship.</p>

          <p>To force synchronization of the managed entity to the data store, invoke the <code>flush</code> method of the <code>EntityManager</code> instance. If the entity is related to another entity and the relationship annotation has the <code>cascade</code> element set to <code>PERSIST</code> or <code>ALL</code>, the related entity's data will be synchronized with the data store when <code>flush</code> is called.</p>

          <p>If the entity is removed, calling <code>flush</code> will remove the entity data from the data store.</p>
        </div>
      </div><a id="BNBRJ"></a><a id="JEETT01162"></a>

      <div class="sect2">
        <h2 class="sect2"><span class="secnum">37.3.2</span> <a id="sthref1900"></a><a id="sthref1901"></a>Persistence Units</h2>

        <p>A persistence unit defines a set of all entity classes that are managed by <code>EntityManager</code> instances in an application. This set of entity classes represents the data contained within a single data store.</p>

        <p><a id="sthref1902"></a>Persistence units are defined by the <code>persistence.xml</code> configuration file. The following is an example <code>persistence.xml</code> file:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;persistence&gt;
    &lt;persistence-unit name="OrderManagement"&gt;
        &lt;description&gt;This unit manages orders and customers.
            It does not rely on any vendor-specific features and can
            therefore be deployed to any persistence provider.
        &lt;/description&gt;
        &lt;jta-data-source&gt;jdbc/MyOrderDB&lt;/jta-data-source&gt;
        &lt;jar-file&gt;MyOrderApp.jar&lt;/jar-file&gt;
        &lt;class&gt;com.widgets.CustomerOrder&lt;/class&gt;
        &lt;class&gt;com.widgets.Customer&lt;/class&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>

        <p>This file defines a persistence unit named <code>OrderManagement</code>, which uses a JTA-aware data source, <code>jdbc/MyOrderDB</code>. The <code>jar-file</code> and <code>class</code> elements specify managed persistence classes: entity classes, embeddable classes, and mapped superclasses. The <code>jar-file</code> element specifies JAR files that are visible to the packaged persistence unit that contain managed persistence classes, whereas the <code>class</code> element explicitly names managed persistence classes.</p>

        <p>The <code>jta-data-source</code> (for JTA-aware data sources) and <code>non-jta-data-source</code> (for non-JTA-aware data sources) elements specify the global JNDI name of the data source to be used by the container.</p>

        <p>The JAR file or directory whose <code>META-INF</code> directory contains <code>persistence.xml</code> is called the root of the persistence unit. The scope of the persistence unit is determined by the persistence unit's root. Each persistence unit must be identified with a name that is unique to the persistence unit's scope.</p>

        <p>Persistent units can be packaged as part of a WAR or EJB JAR file or can be packaged as a JAR file that can then be included in an WAR or EAR file.</p>

        <ul>
          <li>
            <p>If you package the persistent unit as a set of classes in an EJB JAR file, <code>persistence.xml</code> should be put in the EJB JAR's <code>META-INF</code> directory.</p>
          </li>

          <li>
            <p>If you package the persistence unit as a set of classes in a WAR file, <code>persistence.xml</code> should be located in the WAR file's <code>WEB-INF/classes/META-INF</code> directory.</p>
          </li>

          <li>
            <p>If you package the persistence unit in a JAR file that will be included in a WAR or EAR file, the JAR file should be located in either</p>

            <ul>
              <li>
                <p>The <code>WEB-INF/lib</code> directory of a WAR</p>
              </li>

              <li>
                <p>Or the EAR file's library directory</p>

                <div align="center">
                  <div class="inftblnote">
                    <br />

                    <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
                      <tbody>
                        <tr>
                          <td align="left">
                            <p class="notep1">Note:</p>

                            <p>In the Java Persistence API 1.0, JAR files could be located at the root of an EAR file as the root of the persistence unit. This is no longer supported. Portable applications should use the EAR file's library directory as the root of the persistence unit.</p>
                          </td>
                        </tr>
                      </tbody>
                    </table><br />
                  </div>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GJISE"></a><a id="JEETT00491"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.4</span> <a id="sthref1903"></a><a id="sthref1904"></a>Querying Entities</h1>

      <p>The Java Persistence API provides the following methods for querying entities.</p>

      <ul>
        <li>
          <p>The Java Persistence query language (JPQL) is a simple, string-based language similar to SQL used to query entities and their relationships. See <a href="../Text/persistence-querylanguage.xhtml#BNBTG">Chapter 39, "The Java Persistence Query Language"</a> for more information.</p>
        </li>

        <li>
          <p>The Criteria API is used to create typesafe queries using Java programming language APIs to query for entities and their relationships. See <a href="../Text/persistence-criteria.xhtml#GJITV">Chapter 40, "Using the Criteria API to Create Queries"</a> for more information.</p>
        </li>
      </ul>

      <p>Both JPQL and the Criteria API have advantages and disadvantages.</p>

      <p>Just a few lines long, JPQL queries are typically more concise and more readable than Criteria queries. Developers familiar with SQL will find it easy to learn the syntax of JPQL. JPQL named queries can be defined in the entity class using a Java programming language annotation or in the application's deployment descriptor. JPQL queries are not typesafe, however, and require a cast when retrieving the query result from the entity manager. This means that type-casting errors may not be caught at compile time. JPQL queries don't support open-ended parameters.</p>

      <p>Criteria queries allow you to define the query in the business tier of the application. Although this is also possible using JPQL dynamic queries, Criteria queries provide better performance because JPQL dynamic queries must be parsed each time they are called. Criteria queries are typesafe and therefore don't require casting, as JPQL queries do. The Criteria API is just another Java programming language API and doesn't require developers to learn the syntax of another query language. Criteria queries are typically more verbose than JPQL queries and require the developer to create several objects and perform operations on those objects before submitting the query to the entity manager.</p>
    </div>
  </div>

  <div class="ind">
    <a id="CHDBEGIC"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.5</span> <a id="sthref1905"></a><a id="sthref1906"></a>Database Schema Creation</h1>

      <p>The persistence provider can be configured to automatically create the database tables, load data into the tables, and remove the tables during application deployment using standard properties in the application's deployment descriptor. These tasks are typically used during the development phase of a release, not against a production database.</p>

      <p>The following is an example of a <code>persistence.xml</code> deployment descriptor that specifies that the provider should drop all database artifacts using a provided script, create the artifacts with a provided script, and load data from a provided script when the application is deployed:</p>
      <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1" xmlns="http://xmlns.jcp.org/xml/ns/persistence"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
  &lt;persistence-unit name="examplePU" transaction-type="JTA"&gt;
    &lt;jta-data-source&gt;java:global/ExampleDataSource&lt;/jta-data-source&gt;
    &lt;properties&gt;
        &lt;property name="javax.persistence.schema-generation.database.action"
                  value="drop-and-create"/&gt;
        &lt;property name="javax.persistence.schema-generation.create-source"
                  value="script"/&gt;
        &lt;property name="javax.persistence.schema-generation.create-script-source"
                  value="META-INF/sql/create.sql" /&gt;
        &lt;property name="javax.persistence.sql-load-script-source"
                  value="META-INF/sql/data.sql" /&gt;
        &lt;property name="javax.persistence.schema-generation.drop-source"
                  value="script" /&gt;
        &lt;property name="javax.persistence.schema-generation.drop-script-source"
                  value="META-INF/sql/drop.sql" /&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>

      <div class="sect2">
        <a id="sthref1907"></a>

        <h2 class="sect2"><span class="secnum">37.5.1</span> <a id="sthref1908"></a><a id="sthref1909"></a><a id="sthref1910"></a><a id="sthref1911"></a>Configuring an Application to Create or Drop Database Tables</h2>

        <p>The <code>javax.persistence.schema-generation.database.action</code> property is used to specify the action taken by the persistence provider when an application is deployed. If the property is not set, the persistence provider will not create or drop any database artifacts.</p>

        <div class="tblformal">
          <a id="sthref1912"></a><a id="sthref1913"></a>

          <p class="titleintable">Table 37-3 Schema Creation Actions</p>

          <table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="The settings for the javax.persistence.schema-generation.database.action property." title="Schema Creation Actions" width="100%">
            <col width="31%" />
            <col width="*" />

            <thead>
              <tr align="left" valign="top">
                <th align="left" id="r1c1-t5" valign="bottom">Setting</th>

                <th align="left" id="r1c2-t5" valign="bottom">Description</th>
              </tr>
            </thead>

            <tbody>
              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t5" id="r2c1-t5">
                  <p><code>none</code></p>
                </td>

                <td align="left" headers="r2c1-t5 r1c2-t5">
                  <p>No schema creation or deletion will take place.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t5" id="r3c1-t5">
                  <p><code>create</code></p>
                </td>

                <td align="left" headers="r3c1-t5 r1c2-t5">
                  <p>The provider will create the database artifacts on application deployment. The artifacts will remain unchanged after application redeployment.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t5" id="r4c1-t5">
                  <p><code>drop-and-create</code></p>
                </td>

                <td align="left" headers="r4c1-t5 r1c2-t5">
                  <p>Any artifacts in the database will be deleted, and the provider will create the database artifacts on deployment.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t5" id="r5c1-t5">
                  <p><code>drop</code></p>
                </td>

                <td align="left" headers="r5c1-t5 r1c2-t5">
                  <p>Any artifacts in the database will be deleted on application deployment.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>

        <p>In this example, the persistence provider will delete any remaining database artifacts and then create the artifacts when the application is deployed:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;property name="javax.persistence.schema-generation.database.action"
           value="drop-and-create"/&gt;</pre>

        <p>By default, the object/relational metadata in the persistence unit is used to create the database artifacts. You may also supply <a id="sthref1914"></a><a id="sthref1915"></a>scripts used by the provider to create and delete the database artifacts. The <code>javax.persistence.schema-generation.create-source</code> and <code>javax.persistence.schema-generation.drop-source</code> properties control how the provider will create or delete the database artifacts.</p>

        <div class="tblformal">
          <a id="sthref1916"></a><a id="sthref1917"></a>

          <p class="titleintable">Table 37-4 Settings for Create and Delete Source Properties</p>

          <table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="The options for the javax.persistence.schema-generation.create-source and javax.persistence.schema-generation.drop-source properties." title="Settings for Create and Delete Source Properties" width="100%">
            <col width="31%" />
            <col width="*" />

            <thead>
              <tr align="left" valign="top">
                <th align="left" id="r1c1-t6" valign="bottom">Setting</th>

                <th align="left" id="r1c2-t6" valign="bottom">Description</th>
              </tr>
            </thead>

            <tbody>
              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r2c1-t6">
                  <p><code>metadata</code></p>
                </td>

                <td align="left" headers="r2c1-t6 r1c2-t6">
                  <p>Use the object/relational metadata in the application to create or delete the database artifacts.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r3c1-t6">
                  <p><code>script</code></p>
                </td>

                <td align="left" headers="r3c1-t6 r1c2-t6">
                  <p>Use a provided script for creating or deleting the database artifacts.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r4c1-t6">
                  <p><code>metadata-then-script</code></p>
                </td>

                <td align="left" headers="r4c1-t6 r1c2-t6">
                  <p>Use a combination of object/relational metadata, then a user-provided script to create or delete the database artifacts.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t6" id="r5c1-t6">
                  <p><code>script-then-metadata</code></p>
                </td>

                <td align="left" headers="r5c1-t6 r1c2-t6">
                  <p>Use a combination of a user-provided script, then the object/relational metadata to create and delete the database artifacts.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>

        <p>In this example, the persistence provider will use a script packaged within the application to create the database artifacts:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;property name="javax.persistence.schema-generation.create-source"
           value="script"/&gt;</pre>

        <p>If you specify a script in <code>create-source</code> or <code>drop-source</code>, specify the location of the script using the <code>javax.persistence.schema-generation.create-script-source</code> or <code>javax.persistence.schema-generation.drop-script-source</code> property. The location of the script is relative to the root of the persistence unit:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;property name="javax.persistence.schema-generation.create-script-source"
           value="META-INF/sql/create.sql" /&gt;</pre>

        <p>In the above example, the <code>create-script-source</code> is set to a SQL file called <code>create.sql</code> in the <code>META-INF/sql</code> directory relative to root of the persistence unit.</p>
      </div>

      <div class="sect2">
        <a id="sthref1918"></a>

        <h2 class="sect2"><span class="secnum">37.5.2</span> Loading Data Using SQL Scripts</h2>

        <p><a id="sthref1919"></a><a id="sthref1920"></a><a id="sthref1921"></a>If you want to <a id="sthref1922"></a>populate the database tables with data before the application loads, specify the location of a load script in the <code>javax.persistence.sql-load-script-source property</code>. The location specified in this property is relative to the root of the persistence unit.</p>

        <p>In this example, the load script is a file called <code>data.sql</code> in the <code>META-INF/sql</code> directory relative to the root of the persistence unit:</p>
        <pre class="oac_no_warn" xml:space="preserve" xmlns:xml="http://www.w3.org/XML/1998/namespace">&lt;property name="javax.persistence.sql-load-script-source"
          value="META-INF/sql/data.sql" /&gt;</pre>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GKCLC"></a><a id="JEETT00492"></a>

    <div class="sect1">
      <h1 class="sect1"><span class="secnum">37.6</span> Further Information about Persistence</h1>

      <p>For more information about the Java Persistence API, see</p>

      <ul>
        <li>
          <p>Java Persistence 2.1 API specification:</p>

          <p><code><a href="../Text/persistence-intro.xhtml#http%3A//jcp.org/en/jsr/detail%3Fid%3D338">http://jcp.org/en/jsr/detail?id=338</a></code></p>
        </li>

        <li>
          <p>EclipseLink, the Java Persistence API implementation in GlassFish Server:</p>

          <p><code><a href="../Text/persistence-intro.xhtml#http%3A//www.eclipse.org/eclipselink/jpa.php">http://www.eclipse.org/eclipselink/jpa.php</a></code></p>
        </li>

        <li>
          <p>EclipseLink team blog:</p>

          <p><code><a href="../Text/persistence-intro.xhtml#http%3A//eclipselink.blogspot.com/">http://eclipselink.blogspot.com/</a></code></p>
        </li>

        <li>
          <p>EclipseLink wiki documentation:</p>

          <p><code><a href="../Text/persistence-intro.xhtml#http%3A//wiki.eclipse.org/EclipseLink">http://wiki.eclipse.org/EclipseLink</a></code></p>
        </li>
      </ul>
    </div>
  </div>
</body>
</html>
