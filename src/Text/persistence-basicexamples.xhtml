<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/javaee-darb.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="ind">
    <a id="GIJST"></a><a id="JEETT00096"></a>

    <h1 class="chapter"><span class="secnum">38</span> <a id="sthref1923"></a><a id="sthref1924"></a>Running the Persistence Examples</h1>

    <p>This chapter explains how to use the Java Persistence API. The material here focuses on the source code and settings of three examples. The first example, <code>order</code>, is an application that uses a stateful session bean to manage entities related to an ordering system. The second example, <code>roster</code>, is an application that manages a community sports system. The third example, <code>address-book</code>, is a web application that stores contact data. This chapter assumes that you are familiar with the concepts detailed in <a href="../Text/persistence-intro.xhtml#BNBPZ">Chapter 37, "Introduction to the Java Persistence API"</a>.</p>

    <p>The following topics are addressed here:</p>

    <ul>
      <li>
        <p><a href="../Text/persistence-basicexamples.xhtml#GIQST">The order Application</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-basicexamples.xhtml#GIQSQ">The roster Application</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-basicexamples.xhtml#GKANQ">The address-book Application</a></p>
      </li>
    </ul>
  </div>

  <div class="ind">
    <a id="GIQST"></a><a id="JEETT00493"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_690"><span class="secnum">38.1</span> The order Application</h1>

      <p>The <code>order</code> application is a simple inventory and ordering application for maintaining a catalog of parts and placing an itemized order of those parts. The application has entities that represent parts, vendors, orders, and line items. These entities are accessed using a stateful session bean that holds the business logic of the application. A simple singleton session bean creates the initial entities on application deployment. A Facelets web application manipulates the data and displays data from the catalog.</p>

      <p>The information contained in an order can be divided into elements. What is the order number? What parts are included in the order? What parts make up that part? Who makes the part? What are the specifications for the part? Are there any schematics for the part? The <code>order</code> application is a simplified version of an ordering system that has all these elements.</p>

      <p>The <code>order</code> application consists of a single WAR module that includes the enterprise bean classes, the entities, the support classes, and the Facelets XHTML and class files.</p>

      <p>The database schema in the Java DB database for <code>order</code> is shown in <a href="../Text/persistence-basicexamples.xhtml#CHDGGDIA">Figure 38-1</a>.</p>

      <div class="figure">
        <a id="CHDGGDIA"></a>

        <p class="titleinfigure">Figure 38-1 Database Schema for the order Application</p><br />
        <a href="../Text/img_text/jeett_dt_.xhtml#img_text/jeett_dt_024.htm" id="sthref1925">Description of "Figure 38-1 Database Schema for the order Application"</a><br />
        <br />
      </div>

      <div align="center">
        <div class="inftblnote">
          <br />

          <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
            <tbody>
              <tr>
                <td align="left">
                  <p class="notep1">Note:</p>

                  <p>In this diagram, for simplicity, the <code>PERSISTENCE_ORDER_</code> prefix is omitted from the table names.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>
      </div><a id="GIQRH"></a><a id="JEETT01163"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_691"><span class="secnum">38.1.1</span> <a id="sthref1926"></a>Entity Relationships in the order Application</h2>

        <p>The <code>order</code> application demonstrates several types of entity relationships: self-referential, one-to-one, one-to-many, many-to-one, and unidirectional relationships.</p><a id="GIQQR"></a><a id="JEETT00689"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.1.1</span> <a id="sthref1927"></a>Self-Referential Relationships</h3>

          <p>A <span class="glossaryterm">self-referential</span> relationship occurs between relationship fields in the same entity. <code>Part</code> has a field, <code>bomPart</code>, which has a one-to-many relationship with the field <code>parts</code>, which is also in <code>Part</code>. That is, a part can be made up of many parts, and each of those parts has exactly one bill-of-material part.</p>

          <p>The primary key for <code>Part</code> is a compound primary key, a combination of the <code>partNumber</code> and <code>revision</code> fields. This key is mapped to the <code>PARTNUMBER</code> and <code>REVISION</code> columns in the <code>PERSISTENCE_ORDER_PART</code> table:</p>
          <pre class="oac_no_warn" xml:space="preserve">
...
@ManyToOne
@JoinColumns({
    @JoinColumn(name="BOMPARTNUMBER", referencedColumnName="PARTNUMBER"),
    @JoinColumn(name="BOMREVISION", referencedColumnName="REVISION")
})
public Part getBomPart() {
    return bomPart;
}
...
@OneToMany(mappedBy="bomPart")
public Collection&lt;Part&gt; getParts() {
    return parts;
}
...
</pre>
        </div><a id="GIQSR"></a><a id="JEETT00690"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.1.2</span> <a id="sthref1928"></a>One-to-One Relationships</h3>

          <p><code>Part</code> has a field, <code>vendorPart</code>, that has a one-to-one relationship with <code>VendorPart</code>'s <code>part</code> field. That is, each part has exactly one vendor part, and vice versa.</p>

          <p>Here is the relationship mapping in <code>Part</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@OneToOne(mappedBy="part")
public VendorPart getVendorPart() {
    return vendorPart;
}
</pre>

          <p>Here is the relationship mapping in <code>VendorPart</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@OneToOne
@JoinColumns({
    @JoinColumn(name="PARTNUMBER", referencedColumnName="PARTNUMBER"),
    @JoinColumn(name="PARTREVISION", referencedColumnName="REVISION")
})
public Part getPart() {
    return part;
}
</pre>

          <p>Note that, because <code>Part</code> uses a compound primary key, the <code>@JoinColumns</code> annotation is used to map the columns in the <code>PERSISTENCE_ORDER_VENDOR_PART</code> table to the columns in <code>PERSISTENCE_ORDER_PART</code>. The <code>PERSISTENCE_ORDER_VENDOR_PART</code> table's <code>PARTREVISION</code> column refers to <code>PERSISTENCE_ORDER_PART</code>'s <code>REVISION</code> column.</p>
        </div><a id="GIQTJ"></a><a id="JEETT00691"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.1.3</span> <a id="sthref1929"></a><a id="sthref1930"></a><a id="sthref1931"></a>One-to-Many Relationship Mapped to Overlapping Primary and Foreign Keys</h3>

          <p><code>CustomerOrder</code> has a field, <code>lineItems</code>, that has a one-to-many relationship with <code>LineItem</code>'s field <code>customerOrder</code>. That is, each order has one or more line item.</p>

          <p><code>LineItem</code> uses a compound primary key that is made up of the <code>orderId</code> and <code>itemId</code> fields. This compound primary key maps to the <code>ORDERID</code> and <code>ITEMID</code> columns in the <code>PERSISTENCE_ORDER_LINEITEM</code> table. <code>ORDERID</code> is a foreign key to the <code>ORDERID</code> column in the <code>PERSISTENCE_ORDER_CUSTOMERORDER</code> table. This means that the <code>ORDERID</code> column is mapped twice: once as a primary key field, <code>orderId</code>; and again as a relationship field, <code>order</code>.</p>

          <p>Here is the relationship mapping in <code>CustomerOrder</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@OneToMany(cascade=ALL, mappedBy="customerOrder")
public Collection&lt;LineItem&gt; getLineItems() {
    return lineItems;
}
</pre>

          <p>Here is the relationship mapping in <code>LineItem</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
</pre>
        </div><a id="GIQUD"></a><a id="JEETT00692"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.1.4</span> <a id="sthref1932"></a>Unidirectional Relationships</h3>

          <p><code>LineItem</code> has a field, <code>vendorPart</code>, that has a unidirectional many-to-one relationship with <code>VendorPart</code>. That is, there is no field in the target entity in this relationship:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@JoinColumn(name="VENDORPARTNUMBER")
@ManyToOne
public VendorPart getVendorPart() {
    return vendorPart;
}
</pre>
        </div>
      </div><a id="GIQQY"></a><a id="JEETT01164"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_692"><span class="secnum">38.1.2</span> Primary Keys in the order Application</h2>

        <p>The <code>order</code> application uses several types of primary keys: single-valued primary keys, generated primary keys, and compound primary keys.</p><a id="GIQUV"></a><a id="JEETT00693"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.2.1</span> <a id="sthref1933"></a><a id="sthref1934"></a>Generated Primary Keys</h3>

          <p><code>VendorPart</code> uses a generated primary key value. That is, the application does not assign primary key values for the entities but instead relies on the persistence provider to generate the primary key values. The <code>@GeneratedValue</code> annotation is used to specify that an entity will use a generated primary key.</p>

          <p>In <code>VendorPart</code>, the following code specifies the settings for generating primary key values:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@TableGenerator(
    name="vendorPartGen",
    table="PERSISTENCE_ORDER_SEQUENCE_GENERATOR",
    pkColumnName="GEN_KEY",
    valueColumnName="GEN_VALUE",
    pkColumnValue="VENDOR_PART_ID",
    allocationSize=10)
@Id
@GeneratedValue(strategy=GenerationType.TABLE, generator="vendorPartGen")
public Long getVendorPartNumber() {
    return vendorPartNumber;
}
</pre>

          <p>The <code>@TableGenerator</code> annotation is used in conjunction with <code>@GeneratedValue</code>'s <code>strategy=TABLE</code> element. That is, the strategy used to generate the primary keys is to use a table in the database. The <code>@TableGenerator</code> annotation is used to configure the settings for the generator table. The name element sets the name of the generator, which is <code>vendorPartGen</code> in <code>VendorPart</code>.</p>

          <p>The <code>PERSISTENCE_ORDER_SEQUENCE_GENERATOR</code> table, whose two columns are <code>GEN_KEY</code> and <code>GEN_VALUE</code>, will store the generated primary key values. This table could be used to generate other entities' primary keys, so the <code>pkColumnValue</code> element is set to <code>VENDOR_PART_ID</code> to distinguish this entity's generated primary keys from other entities' generated primary keys. The <code>allocationSize</code> element specifies the amount to increment when allocating primary key values. In this case, each <code>VendorPart</code>'s primary key will increment by 10.</p>

          <p>The primary key field <code>vendorPartNumber</code> is of type <code>Long</code>, as the generated primary key's field must be an integral type.</p>
        </div><a id="GIQUF"></a><a id="JEETT00694"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.2.2</span> <a id="sthref1935"></a><a id="sthref1936"></a>Compound Primary Keys</h3>

          <p>A compound primary key is made up of multiple fields and follows the requirements described in <a href="../Text/persistence-intro.xhtml#BNBQF">Primary Keys in Entities</a>. To use a compound primary key, you must create a wrapper class.</p>

          <p>In <code>order</code>, two entities use compound primary keys: <code>Part</code> and <code>LineItem</code>.</p>

          <ul>
            <li>
              <p><code>Part</code> uses the <code>PartKey</code> wrapper class. <code>Part</code>'s primary key is a combination of the part number and the revision number. <code>PartKey</code> encapsulates this primary key.</p>
            </li>

            <li>
              <p><code>LineItem</code> uses the <code>LineItemKey</code> class. <code>LineItem</code>'s primary key is a combination of the order number and the item number. <code>LineItemKey</code> encapsulates this primary key.</p>
            </li>
          </ul>

          <p>This is the <code>LineItemKey</code> compound primary key wrapper class:</p>
          <pre class="oac_no_warn" xml:space="preserve">
package javaeetutorial.order.entity;

import java.io.Serializable;

public final class LineItemKey implements Serializable {

    private Integer customerOrder;
    private int itemId;

    public LineItemKey() {}

    public LineItemKey(Integer order, int itemId) {
        this.setCustomerOrder(order);
        this.setItemId(itemId);
    } 

    @Override
    public int hashCode() {
        return ((this.getCustomerOrder() == null
                ? 0 : this.getCustomerOrder().hashCode())
                ^ ((int) this.getItemId()));
    }

    @Override
    public boolean equals(Object otherOb) {
        if (this == otherOb) {
            return true;
        }
        if (!(otherOb instanceof LineItemKey)) {
            return false;
        }
        LineItemKey other = (LineItemKey) otherOb;
        return ((this.getCustomerOrder() == null
                ? other.getCustomerOrder == null : this.getOrderId()
                .equals(other.getCustomerOrder())) 
                &amp;&amp; (this.getItemId == oother.getItemId()));
    }

    @Override
    public String toString() {
        return "" + getCustomerOrder() + "-" + getItemId();
    }

    public Integer getCustomerOrder() {
        return customerOrder;
    }

    public void setCustomerOrder(Integer order) {
        this.customerOrder = order;
    }

    public int getItemId() {
        return itemId;
    }

    public void setItemId(int itemId) {
        this.itemId = itemId;
    }
}
</pre>

          <p>The <code>@IdClass</code> annotation is used to specify the primary key class in the entity class. In <code>LineItem</code>, <code>@IdClass</code> is used as follows:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@IdClass(LineItemKey.class)
@Entity
...
public class LineItem implements Serializable {
    ...
}
</pre>

          <p>The two fields in <code>LineItem</code> are tagged with the <code>@Id</code> annotation to mark those fields as part of the compound primary key:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@Id
public int getItemId() {
    return itemId;
}
...
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
</pre>

          <p>For <code>customerOrder</code>, you also use the <code>@JoinColumn</code> annotation to specify the column name in the table and that this column is an overlapping foreign key pointing at the <code>PERSISTENCE_ORDER_CUSTOMERORDER</code> table's <code>ORDERID</code> column (see <a href="../Text/persistence-basicexamples.xhtml#GIQTJ">One-to-Many Relationship Mapped to Overlapping Primary and Foreign Keys</a>). That is, <code>customerOrder</code> will be set by the <code>CustomerOrder</code> entity.</p>

          <p>In <code>LineItem</code>'s constructor, the line item number (<code>LineItem.itemId</code>) is set using the <code>CustomerOrder.getNextId</code> method:</p>
          <pre class="oac_no_warn" xml:space="preserve">
public LineItem(CustomerOrder order, int quantity, VendorPart vendorPart) {
    this.customerOrder = order;
    this.itemId = order.getNextId();
    this.quantity = quantity;
    this.vendorPart = vendorPart;
}
</pre>

          <p><code>CustomerOrder.getNextId</code> counts the number of current line items, adds 1, and returns that number:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@Transient
public int getNextId() {
    return this.lineItems.size() + 1;
}
</pre>

          <p><code>Part</code> requires the <code>@Column</code> annotation on the two fields that comprise <code>Part</code>'s compound primary key, because <code>Part</code>'s compound primary key is an overlapping primary key/foreign key:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@IdClass(PartKey.class)
@Entity
...
public class Part implements Serializable {
    ...
    @Id
    @Column(nullable=false)
    public String getPartNumber() {
        return partNumber;
    }
    ...
    @Id
    @Column(nullable=false)
    public int getRevision() {
        return revision;
    }
    ...
}
</pre>
        </div>
      </div><a id="GIQTL"></a><a id="JEETT01165"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_693"><span class="secnum">38.1.3</span> <a id="sthref1937"></a>Entity Mapped to More Than One Database Table</h2>

        <p><code>Part</code>'s fields map to more than one database table: <code>PERSISTENCE_ORDER_PART</code> and <code>PERSISTENCE_ORDER_PART_DETAIL</code>. The <code>PERSISTENCE_ORDER_PART_DETAIL</code> table holds the specification and schematics for the part. The <code>@SecondaryTable</code> annotation is used to specify the secondary table:</p>
        <pre class="oac_no_warn" xml:space="preserve">
...
@Entity
@Table(name="PERSISTENCE_ORDER_PART")
@SecondaryTable(name="PERSISTENCE_ORDER_PART_DETAIL", pkJoinColumns={
    @PrimaryKeyJoinColumn(name="PARTNUMBER",
        referencedColumnName="PARTNUMBER"),
    @PrimaryKeyJoinColumn(name="REVISION",
        referencedColumnName="REVISION")
})
public class Part implements Serializable {
    ...
}
</pre>

        <p><code>PERSISTENCE_ORDER_PART_DETAIL</code> and <code>PERSISTENCE_ORDER_PART</code> share the same primary key values. The <code>pkJoinColumns</code> element of <code>@SecondaryTable</code> is used to specify that <code>PERSISTENCE_ORDER_PART_DETAIL</code>'s primary key columns are foreign keys to <code>PERSISTENCE_ORDER_PART</code>. The <code>@PrimaryKeyJoinColumn</code> annotation sets the primary key column names and specifies which column in the primary table the column refers to. In this case, the primary key column names for both <code>PERSISTENCE_ORDER_PART_DETAIL</code> and <code>PERSISTENCE_ORDER_PART</code> are the same: <code>PARTNUMBER</code> and <code>REVISION</code>, respectively.</p>
      </div><a id="GIQUE"></a><a id="JEETT01166"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_694"><span class="secnum">38.1.4</span> <a id="sthref1938"></a>Cascade Operations in the order Application</h2>

        <p>Entities that have relationships to other entities often have dependencies on the existence of the other entity in the relationship. For example, a line item is part of an order; if the order is deleted, then the line item also should be deleted. This is called a cascade delete relationship.</p>

        <p>In <code>order</code>, there are two cascade delete dependencies in the entity relationships. If the <code>CustomerOrder</code> to which a <code>LineItem</code> is related is deleted, the <code>LineItem</code> also should be deleted. If the <code>Vendor</code> to which a <code>VendorPart</code> is related is deleted, the <code>VendorPart</code> also should be deleted.</p>

        <p>You specify the cascade operations for entity relationships by setting the <code>cascade</code> element in the inverse (nonowning) side of the relationship. The cascade element is set to <code>ALL</code> in the case of <code>CustomerOrder.lineItems</code>. This means that all persistence operations (deletes, updates, and so on) are cascaded from orders to line items.</p>

        <p>Here is the relationship mapping in <code>CustomerOrder</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@OneToMany(cascade=ALL, mappedBy="customerOrder")
public Collection&lt;LineItem&gt; getLineItems() {
    return lineItems;
}
</pre>

        <p>Here is the relationship mapping in <code>LineItem</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
</pre>
      </div><a id="GIQSC"></a><a id="JEETT01167"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_695"><span class="secnum">38.1.5</span> <a id="sthref1939"></a><a id="sthref1940"></a>BLOB and CLOB Database Types in the order Application</h2>

        <p>The <code>PARTDETAIL</code> table in the database has a column, <code>DRAWING</code>, of type <code>BLOB</code>. <code>BLOB</code> stands for binary large objects, which are used for storing binary data, such as an image. The <code>DRAWING</code> column is mapped to the field <code>Part.drawing</code> of type <code>java.io.Serializable</code>. The <code>@Lob</code> annotation is used to denote that the field is a large object:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Column(table="PERSISTENCE_ORDER_PART_DETAIL")
@Lob
public Serializable getDrawing() {
    return drawing;
}
</pre>

        <p><code>PERSISTENCE_ORDER_PART_DETAIL</code> also has a column, <code>SPECIFICATION</code>, of type <code>CLOB</code>. <code>CLOB</code> stands for character large objects, which are used to store string data too large to be stored in a <code>VARCHAR</code> column. <code>SPECIFICATION</code> is mapped to the field <code>Part.specification</code> of type <code>java.lang.String</code>. The <code>@Lob</code> annotation is also used here to denote that the field is a large object:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Column(table="PERSISTENCE_ORDER_PART_DETAIL")
@Lob
public String getSpecification() {
    return specification;
}
</pre>

        <p>Both of these fields use the <code>@Column</code> annotation and set the <code>table</code> element to the secondary table.</p>
      </div><a id="GIQUM"></a><a id="JEETT01168"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_696"><span class="secnum">38.1.6</span> <a id="sthref1941"></a>Temporal Types in the order Application</h2>

        <p>The <code>CustomerOrder.lastUpdate</code> persistent property, which is of type <code>java.util.Date</code>, is mapped to the <code>PERSISTENCE_ORDER_CUSTOMERORDER.LASTUPDATE</code> database field, which is of the SQL type <code>TIMESTAMP</code>. To ensure the proper mapping between these types, you must use the <code>@Temporal</code> annotation with the proper temporal type specified in <code>@Temporal</code>'s element. <code>@Temporal</code>'s elements are of type <code>javax.persistence.TemporalType</code>. The possible values are</p>

        <ul>
          <li>
            <p><code>DATE</code>, which maps to <code>java.sql.Date</code></p>
          </li>

          <li>
            <p><code>TIME</code>, which maps to <code>java.sql.Time</code></p>
          </li>

          <li>
            <p><code>TIMESTAMP</code>, which maps to <code>java.sql.Timestamp</code></p>
          </li>
        </ul>

        <p>Here is the relevant section of <code>CustomerOrder</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Temporal(TIMESTAMP)
public Date getLastUpdate() {
    return lastUpdate;
}
</pre>
      </div><a id="GIQQV"></a><a id="JEETT01169"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_697"><span class="secnum">38.1.7</span> <a id="sthref1942"></a>Managing the order Application's Entities</h2>

        <p>The <code>RequestBean</code> stateful session bean contains the business logic and manages the entities of <code>order</code>. <code>RequestBean</code> uses the <code>@PersistenceContext</code> annotation to retrieve an entity manager instance, which is used to manage <code>order</code>'s entities in <code>RequestBean</code>'s business methods:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@PersistenceContext
private EntityManager em;
</pre>

        <p>This <code>EntityManager</code> instance is a container-managed entity manager, so the container takes care of all the transactions involved in managing <code>order</code>'s entities.</p><a id="GIQRR"></a><a id="JEETT00695"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.7.1</span> <a id="sthref1943"></a>Creating Entities</h3>

          <p>The <code>RequestBean.createPart</code> business method creates a new <code>Part</code> entity. The <code>EntityManager.persist</code> method is used to persist the newly created entity to the database:</p>
          <pre class="oac_no_warn" xml:space="preserve">
Part part = new Part(partNumber,
        revision,
        description,
        revisionDate,
        specification,
        drawing);
em.persist(part);
</pre>

          <p>The <code>ConfigBean</code> singleton session bean is used to initialize the data in <code>order</code>. <code>ConfigBean</code> is annotated with <code>@Startup</code>, which indicates that the EJB container should create <code>ConfigBean</code> when <code>order</code> is deployed. The <code>createData</code> method is annotated with <code>@PostConstruct</code> and creates the initial entities used by <code>order</code> by calling <code>RequestBean</code>'s business methods.</p>
        </div><a id="GIQQC"></a><a id="JEETT00696"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.7.2</span> <a id="sthref1944"></a>Finding Entities</h3>

          <p>The <code>RequestBean.getOrderPrice</code> business method returns the price of a given order based on the <code>orderId</code>. The <code>EntityManager.find</code> method is used to retrieve the entity from the database:</p>
          <pre class="oac_no_warn" xml:space="preserve">
CustomerOrder order = em.find(CustomerOrder.class, orderId);
</pre>

          <p>The first argument of <code>EntityManager.find</code> is the entity class, and the second is the primary key.</p>
        </div><a id="GIQUK"></a><a id="JEETT00697"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.7.3</span> <a id="sthref1945"></a>Setting Entity Relationships</h3>

          <p>The <code>RequestBean.createVendorPart</code> business method creates a <code>VendorPart</code> associated with a particular <code>Vendor</code>. The <code>EntityManager.persist</code> method is used to persist the newly created <code>VendorPart</code> entity to the database, and the <code>VendorPart.setVendor</code> and <code>Vendor.setVendorPart</code> methods are used to associate the <code>VendorPart</code> with the <code>Vendor</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
PartKey pkey = new PartKey();
pkey.setPartNumber(partNumber);
pkey.setRevision(revision);

Part part = em.find(Part.class, pkey);

VendorPart vendorPart = new VendorPart(description, price, part);
em.persist(vendorPart);

Vendor vendor = em.find(Vendor.class, vendorId);
vendor.addVendorPart(vendorPart);
vendorPart.setVendor(vendor);
</pre>
        </div><a id="GIQSV"></a><a id="JEETT00698"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.7.4</span> <a id="sthref1946"></a><a id="sthref1947"></a><a id="sthref1948"></a>Using Queries</h3>

          <p>The <code>RequestBean.adjustOrderDiscount</code> business method updates the discount applied to all orders. This method uses the <code>findAllOrders</code> named query, defined in <code>CustomerOrder</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@NamedQuery(
    name="findAllOrders",
    query="SELECT co FROM CustomerOrder co " +
          "ORDER BY co.orderId"
)
</pre>

          <p>The <code>EntityManager.createNamedQuery</code> method is used to run the query. Because the query returns a <code>List</code> of all the orders, the <code>Query.getResultList</code> method is used:</p>
          <pre class="oac_no_warn" xml:space="preserve">
List orders = em.createNamedQuery(
        "findAllOrders")
        .getResultList();
</pre>

          <p>The <code>RequestBean.getTotalPricePerVendor</code> business method returns the total price of all the parts for a particular vendor. This method uses a named parameter, <code>id</code>, defined in the named query <code>findTotalVendorPartPricePerVendor</code> defined in <code>VendorPart</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@NamedQuery(
    name="findTotalVendorPartPricePerVendor",
    query="SELECT SUM(vp.price) " +
    "FROM VendorPart vp " +
    "WHERE vp.vendor.vendorId = :id"
)
</pre>

          <p>When running the query, the <code>Query.setParameter</code> method is used to set the named parameter <code>id</code> to the value of <code>vendorId</code>, the parameter to <code>RequestBean.getTotalPricePerVendor</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
return (Double) em.createNamedQuery(
    "findTotalVendorPartPricePerVendor")
    .setParameter("id", vendorId)
    .getSingleResult();
</pre>

          <p>The <code>Query.getSingleResult</code> method is used for this query because the query returns a single value.</p>
        </div><a id="GIQTW"></a><a id="JEETT00699"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.7.5</span> <a id="sthref1949"></a>Removing Entities</h3>

          <p>The <code>RequestBean.removeOrder</code> business method deletes a given order from the database. This method uses the <code>EntityManager.remove</code> method to delete the entity from the database:</p>
          <pre class="oac_no_warn" xml:space="preserve">
CustomerOrder order = em.find(CustomerOrder.class, orderId);
em.remove(order);
</pre>
        </div>
      </div><a id="GIQUP"></a><a id="JEETT01170"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_698"><span class="secnum">38.1.8</span> Running the order Example</h2>

        <p>You can use either NetBeans IDE or Maven to build, package, deploy, and run the <code>order</code> application. First, you will create the database tables in the Java DB server.</p><a id="GIQSG"></a><a id="JEETT00235"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.8.1</span> To Run the order Example Using NetBeans IDE</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>From the <span class="gui-object-action">File</span> menu, choose <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-title">Open Project</span> dialog box, navigate to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence
</pre>
            </li>

            <li>
              <p>Select the <code>order</code> folder.</p>
            </li>

            <li>
              <p>Click <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-action">Projects</span> tab, right-click the <code>order</code> project and select <span class="gui-object-action">Run</span>.</p>

              <p>NetBeans IDE opens a web browser to the following URL:</p>
              <pre class="oac_no_warn" xml:space="preserve">
http://localhost:8080/order/
</pre>
            </li>
          </ol>
        </div><a id="GIQTY"></a><a id="JEETT00236"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.1.8.2</span> To Run the order Example Using Maven</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>In a terminal window, go to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence/order/
</pre>
            </li>

            <li>
              <p>Enter the following command:</p>
              <pre class="oac_no_warn" xml:space="preserve">
mvn install
</pre>

              <p>This compiles the source files and packages the application into a WAR file located at <span class="variable">tut-install</span><code>/examples/persistence/order/target/order.war</code>. Then the WAR file is deployed to your GlassFish Server instance.</p>
            </li>

            <li>
              <p>To create and update the order data, open a web browser to the following URL:</p>
              <pre class="oac_no_warn" xml:space="preserve">
http://localhost:8080/order/
</pre>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GIQSQ"></a><a id="JEETT00494"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_699"><span class="secnum">38.2</span> The roster Application</h1>

      <p>The <code>roster</code> application maintains the team rosters for players in recreational sports leagues. The application has four components: Java Persistence API entities (<code>Player</code>, <code>Team</code>, and <code>League</code>), a stateful session bean (<code>RequestBean</code>), an application client (<code>RosterClient</code>), and three helper classes (<code>PlayerDetails</code>, <code>TeamDetails</code>, and <code>LeagueDetails</code>).</p>

      <p>Functionally, <code>roster</code> is similar to the <code>order</code> application, with three new features that <code>order</code> does not have: many-to-many relationships, entity inheritance, and automatic table creation at deployment time.</p>

      <p>The database schema in the Java DB database for the <code>roster</code> application is shown in <a href="../Text/persistence-basicexamples.xhtml#CHDCHJHG">Figure 38-2</a>.</p>

      <div class="figure">
        <a id="CHDCHJHG"></a>

        <p class="titleinfigure">Figure 38-2 Database Schema for the roster Application</p><br />
        <a href="../Text/img_text/jeett_dt_.xhtml#img_text/jeett_dt_025.htm" id="sthref1950">Description of "Figure 38-2 Database Schema for the roster Application"</a><br />
        <br />
      </div>

      <div align="center">
        <div class="inftblnote">
          <br />

          <table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
            <tbody>
              <tr>
                <td align="left">
                  <p class="notep1">Note:</p>

                  <p>In this diagram, for simplicity, the <code>PERSISTENCE_ROSTER_</code> prefix is omitted from the table names.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>
      </div><a id="GIQSO"></a><a id="JEETT01171"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_700"><span class="secnum">38.2.1</span> Relationships in the roster Application</h2>

        <p>A recreational sports system has the following relationships.</p>

        <ul>
          <li>
            <p>A player can be on many teams.</p>
          </li>

          <li>
            <p>A team can have many players.</p>
          </li>

          <li>
            <p>A team is in exactly one league.</p>
          </li>

          <li>
            <p>A league has many teams.</p>
          </li>
        </ul>

        <p>In <code>roster</code> this system is reflected by the following relationships between the <code>Player</code>, <code>Team</code>, and <code>League</code> entities.</p>

        <ul>
          <li>
            <p>There is a many-to-many relationship between <code>Player</code> and <code>Team</code>.</p>
          </li>

          <li>
            <p>There is a many-to-one relationship between <code>Team</code> and <code>League</code>.</p>
          </li>
        </ul><a id="GIQQK"></a><a id="JEETT00701"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.1.1</span> <a id="sthref1951"></a><a id="sthref1952"></a>The Many-To-Many Relationship in roster</h3>

          <p>The many-to-many relationship between <code>Player</code> and <code>Team</code> is specified by using the <code>@ManyToMany</code> annotation. In <code>Team.java</code>, the <code>@ManyToMany</code> annotation decorates the <code>getPlayers</code> method:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@ManyToMany
@JoinTable(
    name="PERSISTENCE_ROSTER_TEAM_PLAYER",
    joinColumns=
        @JoinColumn(name="TEAM_ID", referencedColumnName="ID"),
    inverseJoinColumns=
        @JoinColumn(name="PLAYER_ID", referencedColumnName="ID")
)
public Collection&lt;Player&gt; getPlayers() {
    return players;
}
</pre>

          <p>The <code>@JoinTable</code> annotation is used to specify a database table that will associate player IDs with team IDs. The entity that specifies the <code>@JoinTable</code> is the owner of the relationship, so the <code>Team</code> entity is the owner of the relationship with the <code>Player</code> entity. Because <code>roster</code> uses automatic table creation at deployment time, the container will create a join table named <code>PERSISTENCE_ROSTER_TEAM_PLAYER</code>.</p>

          <p><code>Player</code> is the inverse, or nonowning, side of the relationship with <code>Team</code>. As one-to-one and many-to-one relationships, the nonowning side is marked by the <code>mappedBy</code> element in the relationship annotation. Because the relationship between <code>Player</code> and <code>Team</code> is bidirectional, the choice of which entity is the owner of the relationship is arbitrary.</p>

          <p>In <code>Player.java</code>, the <code>@ManyToMany</code> annotation decorates the <code>getTeams</code> method:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@ManyToMany(mappedBy="players")
public Collection&lt;Team&gt; getTeams() {
    return teams;
}
</pre>
        </div>
      </div><a id="GIQRF"></a><a id="JEETT01172"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_701"><span class="secnum">38.2.2</span> <a id="sthref1953"></a>Entity Inheritance in the roster Application</h2>

        <p>The <code>roster</code> application shows how to use entity inheritance, as described in <a href="../Text/persistence-intro.xhtml#BNBQN">Entity Inheritance</a>.</p>

        <p>The <code>League</code> entity in <code>roster</code> is an abstract entity with two concrete subclasses: <code>SummerLeague</code> and <code>WinterLeague</code>. Because <code>League</code> is an abstract class, it cannot be instantiated:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Entity
@Table(name = "PERSISTENCE_ROSTER_LEAGUE")
public abstract class League implements Serializable { ... }
</pre>

        <p>Instead, when creating a league, clients use <code>SummerLeague</code> or <code>WinterLeague</code>. <code>SummerLeague</code> and <code>WinterLeague</code> inherit the persistent properties defined in <code>League</code> and add only a constructor that verifies that the sport parameter matches the type of sport allowed in that seasonal league. For example, here is the <code>SummerLeague</code> entity:</p>
        <pre class="oac_no_warn" xml:space="preserve">
...
@Entity
public class SummerLeague extends League implements Serializable {

    /** Creates a new instance of SummerLeague */
    public SummerLeague() {
    }

    public SummerLeague(String id, String name, String sport) 
            throws IncorrectSportException {
        this.id = id;
        this.name = name;
        if (sport.equalsIgnoreCase("swimming") ||
                sport.equalsIgnoreCase("soccer") ||
                sport.equalsIgnoreCase("basketball") ||
                sport.equalsIgnoreCase("baseball")) {
            this.sport = sport;
        } else {
            throw new IncorrectSportException("Sport is not a summer sport.");
        }
    }
}
</pre>

        <p>The <code>roster</code> application uses the default mapping strategy of <code>InheritanceType.SINGLE_TABLE</code>, so the <code>@Inheritance</code> annotation is not required. If you want to use a different mapping strategy, decorate <code>League</code> with <code>@Inheritance</code> and specify the mapping strategy in the <code>strategy</code> element:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Entity
@Inheritance(strategy=JOINED)
@Table(name="PERSISTENCE_ROSTER_LEAGUE")
public abstract class League implements Serializable { ... }
</pre>

        <p>The <code>roster</code> application uses the default discriminator column name, so the <code>@DiscriminatorColumn</code> annotation is not required. Because you are using automatic table generation in <code>roster</code>, the Persistence provider will create a discriminator column called <code>DTYPE</code> in the <code>PERSISTENCE_ROSTER_LEAGUE</code> table, which will store the name of the inherited entity used to create the league. If you want to use a different name for the discriminator column, decorate <code>League</code> with <code>@DiscriminatorColumn</code> and set the <code>name</code> element:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Entity
@DiscriminatorColumn(name="DISCRIMINATOR")
@Table(name="PERSISTENCE_ROSTER_LEAGUE")
public abstract class League implements Serializable { ... }
</pre>
      </div><a id="GJJFL"></a><a id="JEETT01173"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_702"><span class="secnum">38.2.3</span> <a id="sthref1954"></a><a id="sthref1955"></a>Criteria Queries in the roster Application</h2>

        <p>The <code>roster</code> application uses Criteria API queries, as opposed to the JPQL queries used in <code>order</code>. Criteria queries are Java programming language, typesafe queries defined in the business tier of <code>roster</code>, in the <code>RequestBean</code> stateful session bean.</p><a id="GJJEX"></a><a id="JEETT00702"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.3.1</span> <a id="sthref1956"></a>Metamodel Classes in the roster Application</h3>

          <p>Metamodel classes model an entity's attributes and are used by Criteria queries to navigate to an entity's attributes. Each entity class in <code>roster</code> has a corresponding metamodel class, generated at compile time, with the same package name as the entity and appended with an underscore character (_). For example, the <code>roster.entity.Player</code> entity has a corresponding metamodel class, <code>roster.entity.Player_</code>.</p>

          <p>Each persistent field or property in the entity class has a corresponding attribute in the entity's metamodel class. For the <code>Player</code> entity, the corresponding metamodel class is as follows:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@StaticMetamodel(Player.class)
public class Player_ {
    public static volatile SingularAttribute&lt;Player, String&gt; id;
    public static volatile SingularAttribute&lt;Player, String&gt; name;
    public static volatile SingularAttribute&lt;Player, String&gt; position;
    public static volatile SingularAttribute&lt;Player, Double&gt; salary;
    public static volatile CollectionAttribute&lt;Player, Team&gt; teams;
}
</pre>
        </div><a id="GJJFN"></a><a id="JEETT00703"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.3.2</span> Obtaining a CriteriaBuilder Instance in RequestBean</h3>

          <p>The <code>CriteriaBuilder</code> interface defines methods to create criteria query objects and create expressions for modifying those query objects. <code>RequestBean</code> creates an instance of <code>CriteriaBuilder</code> by using a <code>@PostConstruct</code> method, <code>init</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
@PersistenceContext
private EntityManager em;
private CriteriaBuilder cb;

@PostConstruct
private void init() {
    cb = em.getCriteriaBuilder();
}
</pre>

          <p>The <code>EntityManager</code> instance is injected at runtime, and then that <code>EntityManager</code> object is used to create the <code>CriteriaBuilder</code> instance by calling <code>getCriteriaBuilder</code>. The <code>CriteriaBuilder</code> instance is created in a <code>@PostConstruct</code> method to ensure that the <code>EntityManager</code> instance has been injected by the enterprise bean container.</p>
        </div><a id="GJJFF"></a><a id="JEETT00704"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.3.3</span> Creating Criteria Queries in RequestBean's Business Methods</h3>

          <p>Many of the business methods in <code>RequestBean</code> define Criteria queries. One business method, <code>getPlayersByPosition</code>, returns a list of players who play a particular position on a team:</p>
          <pre class="oac_no_warn" xml:space="preserve">
public List&lt;PlayerDetails&gt; getPlayersByPosition(String position) {
    logger.info("getPlayersByPosition");
    List&lt;Player&gt; players = null;
    
    try {
        CriteriaQuery&lt;Player&gt; cq = cb.createQuery(Player.class);
        if (cq != null) {
            Root&lt;Player&gt; player = cq.from(Player.class);

            // set the where clause
            cq.where(cb.equal(player.get(Player_.position), position));
            cq.select(player);
            TypedQuery&lt;Player&gt; q = em.createQuery(cq);
            players = q.getResultList();
        }
        return copyPlayersToDetails(players);
    } catch (Exception ex) {
        throw new EJBException(ex);
    }
}
</pre>

          <p>A query object is created by calling the <code>CriteriaBuilder</code> object's <code>createQuery</code> method, with the type set to <code>Player</code> because the query will return a list of players.</p>

          <p>The query root, the base entity from which the query will navigate to find the entity's attributes and related entities, is created by calling the <code>from</code> method of the query object. This sets the <code>FROM</code> clause of the query.</p>

          <p>The <code>WHERE</code> clause, set by calling the <code>where</code> method on the query object, restricts the results of the query according to the conditions of an expression. The <code>CriteriaBuilder.equal</code> method compares the two expressions. In <code>getPlayersByPosition</code>, the <code>position</code> attribute of the <code>Player_</code> metamodel class, accessed by calling the <code>get</code> method of the query root, is compared to the <code>position</code> parameter passed to <code>getPlayersByPosition</code>.</p>

          <p>The <code>SELECT</code> clause of the query is set by calling the <code>select</code> method of the query object. The query will return <code>Player</code> entities, so the query root object is passed as a parameter to <code>select</code>.</p>

          <p>The query object is prepared for execution by calling <code>EntityManager.createQuery</code>, which returns a <code>TypedQuery&lt;T&gt;</code> object with the type of the query, in this case <code>Player</code>. This typed query object is used to execute the query, which occurs when the <code>getResultList</code> method is called, and a <code>List&lt;Player&gt;</code> collection is returned.</p>
        </div>
      </div><a id="GIQRX"></a><a id="JEETT01174"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_703"><span class="secnum">38.2.4</span> Automatic Table Generation in the roster Application</h2>

        <p>At deployment time, GlassFish Server will automatically drop and create the database tables used by <code>roster</code>. This is done by setting the <code>javax.persistence.schema-generation.database.action</code> property to <code>drop-and-create</code> in <code>persistence.xml</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1" 
    xmlns="http://xmlns.jcp.org/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
        http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
  &lt;persistence-unit name="em" transaction-type="JTA"&gt;
    &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt;
    &lt;properties&gt;
      &lt;property name="javax.persistence.schema-generation.database.action" 
                value="drop-and-create"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>
      </div><a id="GIQUZ"></a><a id="JEETT01175"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_704"><span class="secnum">38.2.5</span> Running the roster Example</h2>

        <p>You can use either NetBeans IDE or Maven to build, package, deploy, and run the <code>roster</code> application.</p><a id="GIQUG"></a><a id="JEETT00237"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.5.1</span> To Run the roster Example Using NetBeans IDE</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>From the <span class="gui-object-action">File</span> menu, choose <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-title">Open Project</span> dialog box, navigate to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence
</pre>
            </li>

            <li>
              <p>Select the <code>roster</code> folder.</p>
            </li>

            <li>
              <p>Select the <span class="gui-object-action">Open Required Projects</span> check box.</p>
            </li>

            <li>
              <p>Click <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-action">Projects</span> tab, right-click the <code>roster</code> project and select <span class="gui-object-action">Build</span>.</p>

              <p>This will compile, package, and deploy the EAR to GlassFish Server.</p>

              <p>You will see the following partial output from the application client in the <span class="gui-object-action">Output</span> tab:</p>
              <pre class="oac_no_warn" xml:space="preserve">
List all players in team T2:
P6 Ian Carlyle goalkeeper 555.0
P7 Rebecca Struthers midfielder 777.0
P8 Anne Anderson forward 65.0
P9 Jan Wesley defender 100.0
P10 Terry Smithson midfielder 100.0

List all teams in league L1:
T1 Honey Bees Visalia
T2 Gophers Manteca
T5 Crows Orland

List all defenders:
P2 Alice Smith defender 505.0
P5 Barney Bold defender 100.0
P9 Jan Wesley defender 100.0
P22 Janice Walker defender 857.0
P25 Frank Fletcher defender 399.0
</pre>
            </li>
          </ol>
        </div><a id="GIQSJ"></a><a id="JEETT00238"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.2.5.2</span> To Run the roster Example Using Maven</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>In a terminal window, go to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence/roster/roster-ear/
</pre>
            </li>

            <li>
              <p>Enter the following command:</p>
              <pre class="oac_no_warn" xml:space="preserve">
mvn install
</pre>

              <p>This compiles the source files and packages the application into an EAR file located at <span class="variable">tut-install</span><code>/examples/persistence/roster/target/roster.ear</code>. The EAR file is then deployed to GlassFish Server. GlassFish Server will then drop and create the database tables during deployment, as specified in <code>persistence.xml</code>.</p>

              <p>After successfully deploying the EAR, the client stubs are retrieved and the application client is run using the appclient application included with GlassFish Server.</p>

              <p>You will see the output, which begins as follows:</p>
              <pre class="oac_no_warn" xml:space="preserve">
[echo] running application client container.
[exec] List all players in team T2:
[exec] P6 Ian Carlyle goalkeeper 555.0
[exec] P7 Rebecca Struthers midfielder 777.0
[exec] P8 Anne Anderson forward 65.0
[exec] P9 Jan Wesley defender 100.0
[exec] P10 Terry Smithson midfielder 100.0

[exec] List all teams in league L1:
[exec] T1 Honey Bees Visalia
[exec] T2 Gophers Manteca
[exec] T5 Crows Orland

[exec] List all defenders:
[exec] P2 Alice Smith defender 505.0
[exec] P5 Barney Bold defender 100.0
[exec] P9 Jan Wesley defender 100.0
[exec] P22 Janice Walker defender 857.0
[exec] P25 Frank Fletcher defender 399.0
</pre>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="GKANQ"></a><a id="JEETT00495"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_705"><span class="secnum">38.3</span> <a id="sthref1957"></a><a id="sthref1958"></a>The address-book Application</h1>

      <p>The <code>address-book</code> example application is a simple web application that stores contact data. It uses a single entity class, <code>Contact</code>, that uses the Java API for JavaBeans Validation (Bean Validation) to validate the data stored in the persistent attributes of the entity, as described in <a href="../Text/persistence-intro.xhtml#GKAHQ">Validating Persistent Fields and Properties</a>.</p><a id="GKAOJ"></a><a id="JEETT01176"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_706"><span class="secnum">38.3.1</span> <a id="sthref1959"></a>Bean Validation Constraints in address-book</h2>

        <p>The <code>Contact</code> entity uses the <code>@NotNull</code>, <code>@Pattern</code>, and <code>@Past</code> constraints on the persistent attributes.</p>

        <p>The <code>@NotNull</code> constraint marks the attribute as a required field. The attribute must be set to a non-null value before the entity can be persisted or modified. Bean Validation will throw a validation error if the attribute is null when the entity is persisted or modified.</p>

        <p>The <code>@Pattern</code> constraint defines a regular expression that the value of the attribute must match before the entity can be persisted or modified. This constraint has two different uses in <code>address-book</code>.</p>

        <ul>
          <li>
            <p>The regular expression declared in the <code>@Pattern</code> annotation on the <code>email</code> field matches email addresses of the form <span class="variable">name</span><code>@</code><span class="variable">domain name</span><code>.</code><span class="variable">top level domain</span>, allowing only valid characters for email addresses. For example, <code>username@example.com</code> will pass validation, as will <code>firstname.lastname@mail.example.com</code>. However, <code>firstname,lastname@example.com</code>, which contains an illegal comma character in the local name, will fail validation.</p>
          </li>

          <li>
            <p>The <code>mobilePhone</code> and <code>homePhone</code> fields are annotated with a <code>@Pattern</code> constraint that defines a regular expression to match phone numbers of the form <code>(</code><span class="variable">xxx</span><code>)</code> <span class="variable">xxx</span><code>-</code><span class="variable">xxxx</span>.</p>
          </li>
        </ul>

        <p>The <code>@Past</code> constraint is applied to the birthday field, which must be a <code>java.util.Date</code> in the past.</p>

        <p>Here are the relevant parts of the <code>Contact</code> entity class:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Entity
public class Contact implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @NotNull
    protected String firstName;
    @NotNull
    protected String lastName;
    @Pattern(regexp = "[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\."
            + "[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@"
            + "(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9]"
            + "(?:[a-z0-9-]*[a-z0-9])?",
            message = "{invalid.email}")
    protected String email;
    @Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
            message = "{invalid.phonenumber}")
    protected String mobilePhone;
    @Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
            message = "{invalid.phonenumber}")
    protected String homePhone;
    @Temporal(javax.persistence.TemporalType.DATE)
    @Past
    protected Date birthday;
    ...
}
</pre>
      </div><a id="GKANL"></a><a id="JEETT01177"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_707"><span class="secnum">38.3.2</span> Specifying Error Messages for Constraints in address-book</h2>

        <p>Some of the constraints in the <code>Contact</code> entity specify an optional message:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
        message = "{invalid.phonenumber}")
protected String homePhone;
</pre>

        <p>The optional message element in the <code>@Pattern</code> constraint overrides the default validation message. The message can be specified directly:</p>
        <pre class="oac_no_warn" xml:space="preserve">
@Pattern(regexp = "^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$",
        message = "Invalid phone number!")
protected String homePhone;
</pre>

        <p>The constraints in <code>Contact</code>, however, are strings in the resource bundle <code>ValidationMessages.properties</code>, under <span class="variable">tut-install</span><code>/examples/persistence/address-book/src/java/</code>. This allows the validation messages to be located in one single properties file and the messages to be easily localized. Overridden Bean Validation messages must be placed in a resource bundle properties file named <code>ValidationMessages.properties</code> in the default package, with localized resource bundles taking the form <code>ValidationMessages_</code><span class="variable">locale-prefix</span><code>.properties</code>. For example, <code>ValidationMessages_es.properties</code> is the resource bundle used in Spanish-speaking locales.</p>
      </div><a id="GKAON"></a><a id="JEETT01178"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_708"><span class="secnum">38.3.3</span> <a id="sthref1960"></a>Validating Contact Input from a JavaServer Faces Application</h2>

        <p>The <code>address-book</code> application uses a JavaServer Faces web front end to allow users to enter contacts. While JavaServer Faces has a form input validation mechanism using tags in Facelets XHTML files, <code>address-book</code> doesn't use these validation tags. Bean Validation constraints in JavaServer Faces managed beans, in this case in the <code>Contact</code> entity, automatically trigger validation when the forms are submitted.</p>

        <p>The following code snippet from the <code>Create.xhtml</code> Facelets file shows some of the input form for creating new <code>Contact</code> instances:</p>
        <pre class="oac_no_warn" xml:space="preserve">
&lt;h:form&gt;
    &lt;table columns="3" role="presentation"&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;h:outputLabel value="#{bundle.CreateContactLabel_firstName}" 
                               for="firstName" /&gt;&lt;/td&gt;
            &lt;td&gt;&lt;h:inputText id="firstName" 
                             value="#{contactController.selected.firstName}" 
                             title="#{bundle.CreateContactTitle_firstName}"/&gt;
            &lt;/td&gt;
            &lt;td&gt;&lt;h:message for="firstName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;h:outputLabel value="#{bundle.CreateContactLabel_lastName}" 
                               for="lastName" /&gt;&lt;/td&gt;
            &lt;td&gt;&lt;h:inputText id="lastName" 
                             value="#{contactController.selected.lastName}" 
                             title="#{bundle.CreateContactTitle_lastName}" /&gt;
            &lt;/td&gt;
            &lt;td&gt;&lt;h:message for="lastName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        ...
    &lt;/table&gt;
&lt;/h:form&gt;
</pre>

        <p>The <code>&lt;h:inputText&gt;</code> tags <code>firstName</code> and <code>lastName</code> are bound to the attributes in the <code>Contact</code> entity instance <code>selected</code> in the <code>ContactController</code> stateless session bean. Each <code>&lt;h:inputText&gt;</code> tag has an associated <code>&lt;h:message&gt;</code> tag that will display validation error messages. The form doesn't require any JavaServer Faces validation tags, however.</p>
      </div><a id="GKAOP"></a><a id="JEETT01179"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_709"><span class="secnum">38.3.4</span> Running the address-book Example</h2>

        <p>You can use either NetBeans IDE or Maven to build, package, deploy, and run the <code>address-book</code> application.</p><a id="GKAOD"></a><a id="JEETT00239"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.3.4.1</span> To Run the address-book Example Using NetBeans IDE</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>From the <span class="gui-object-action">File</span> menu, choose <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-title">Open Project</span> dialog box, navigate to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence
</pre>
            </li>

            <li>
              <p>Select the <code>address-book</code> folder.</p>
            </li>

            <li>
              <p>Click <span class="gui-object-action">Open Project</span>.</p>
            </li>

            <li>
              <p>In the <span class="gui-object-action">Projects</span> tab, right-click the <code>address-book</code> project and select <span class="gui-object-action">Run</span>.</p>

              <p>After the application has been deployed, a web browser window appears at the following URL:</p>
              <pre class="oac_no_warn" xml:space="preserve">
http://localhost:8080/address-book/
</pre>
            </li>

            <li>
              <p>Click <span class="gui-object-action">Show All Contact Items</span>, then <span class="gui-object-action">Create New Contact</span>. Enter values in the fields; then click <span class="gui-object-action">Save</span>.</p>

              <p>If any of the values entered violate the constraints in <code>Contact</code>, an error message will appear in red beside the field with the incorrect values.</p>
            </li>
          </ol>
        </div><a id="GKANZ"></a><a id="JEETT00240"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">38.3.4.2</span> To Run the address-book Example Using Maven</h3>

          <ol>
            <li>
              <p>Make sure that GlassFish Server has been started (see <a href="../Text/usingexamples.xhtml#BNADI">Starting and Stopping GlassFish Server</a>).</p>
            </li>

            <li>
              <p>If the database server is not already running, start it by following the instructions in <a href="../Text/usingexamples.xhtml#BNADK">Starting and Stopping the Java DB Server</a>.</p>
            </li>

            <li>
              <p>In a terminal window, go to:</p>
              <pre class="oac_no_warn" xml:space="preserve">
<span class="variable">tut-install</span>/examples/persistence/address-book/
</pre>
            </li>

            <li>
              <p>Enter the following command:</p>
              <pre class="oac_no_warn" xml:space="preserve">
mvn install
</pre>

              <p>This will compile and assemble the <code>address-book</code> application into a WAR. The WAR file is then deployed to GlassFish Server.</p>
            </li>

            <li>
              <p>Open a web browser window and enter the following URL:</p>
              <pre class="oac_no_warn" xml:space="preserve">
http://localhost:8080/address-book/
</pre>
            </li>

            <li>
              <p>Click <span class="gui-object-action">Show All Contact Items</span>, then <span class="gui-object-action">Create New Contact</span>. Enter values in the fields; then click <span class="gui-object-action">Save</span>.</p>

              <p>If any of the values entered violate the constraints in <code>Contact</code>, an error message will appear in red beside the field with the incorrect values.</p>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
