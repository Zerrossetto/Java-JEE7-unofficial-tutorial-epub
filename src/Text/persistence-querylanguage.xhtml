<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/javaee-darb.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="ind">
    <a id="BNBTG"></a><a id="JEETT00097"></a>

    <h1 class="chapter"><span class="secnum">39</span> The Java Persistence Query Language</h1>

    <p>The Java Persistence query language defines queries for entities and their persistent state. The query language allows you to write portable queries that work regardless of the underlying data store.</p>

    <p><a id="sthref1961"></a><a id="sthref1962"></a><a id="sthref1963"></a>The query language uses the abstract persistence schemas of entities, including their relationships, for its data model and defines operators and expressions based on this data model. The scope of a query spans the abstract schemas of related entities that are packaged in the same persistence unit. The query language uses an SQL-like syntax to select objects or values based on entity abstract schema types and relationships among them.</p>

    <p>This chapter relies on the material presented in earlier chapters. For conceptual information, see <a href="../Text/persistence-intro.xhtml#BNBPZ">Chapter 37, "Introduction to the Java Persistence API"</a>. For code examples, see <a href="../Text/persistence-basicexamples.xhtml#GIJST">Chapter 38, "Running the Persistence Examples."</a></p>

    <p>The following topics are addressed here:</p>

    <ul>
      <li>
        <p><a href="../Text/persistence-querylanguage.xhtml#BNBTH">Query Language Terminology</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-querylanguage.xhtml#BNBRG">Creating Queries Using the Java Persistence Query Language</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-querylanguage.xhtml#BNBTI">Simplified Query Language Syntax</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-querylanguage.xhtml#BNBTL">Example Queries</a></p>
      </li>

      <li>
        <p><a href="../Text/persistence-querylanguage.xhtml#BNBUF">Full Query Language Syntax</a></p>
      </li>
    </ul>
  </div>

  <div class="ind">
    <a id="BNBTH"></a><a id="JEETT00496"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_758"><span class="secnum">39.1</span> Query Language Terminology</h1>

      <p>The following list defines some of the terms referred to in this chapter.</p>

      <ul>
        <li>
          <p><a id="sthref1964"></a><a id="sthref1965"></a><span class="glossaryterm">Abstract schema</span>: The persistent schema abstraction (persistent entities, their state, and their relationships) over which queries operate. The query language translates queries over this persistent schema abstraction into queries that are executed over the database schema to which entities are mapped.</p>
        </li>

        <li>
          <p><a id="sthref1966"></a><span class="glossaryterm">Abstract schema type</span>: The type to which the persistent property of an entity evaluates in the abstract schema. That is, each persistent field or property in an entity has a corresponding state field of the same type in the abstract schema. The abstract schema type of an entity is derived from the entity class and the metadata information provided by Java language annotations.</p>
        </li>

        <li>
          <p><span class="glossaryterm">Backus-Naur Form (BNF)</span>: A notation that describes the syntax of high-level languages. The syntax diagrams in this chapter are in BNF notation.</p>
        </li>

        <li>
          <p><a id="sthref1967"></a><span class="glossaryterm">Navigation</span>: The traversal of relationships in a query language expression. The navigation operator is a period.</p>
        </li>

        <li>
          <p><a id="sthref1968"></a><span class="glossaryterm">Path expression</span>: An expression that navigates to an entity's state or relationship field.</p>
        </li>

        <li>
          <p><a id="sthref1969"></a><a id="sthref1970"></a><span class="glossaryterm">State field</span>: A persistent field of an entity.</p>
        </li>

        <li>
          <p><a id="sthref1971"></a><a id="sthref1972"></a><span class="glossaryterm">Relationship field</span>: A persistent field of an entity whose type is the abstract schema type of the related entity.</p>
        </li>
      </ul>
    </div>
  </div>

  <div class="ind">
    <a id="BNBRG"></a><a id="JEETT00497"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_759"><span class="secnum">39.2</span> <a id="sthref1973"></a>Creating Queries Using the Java Persistence Query Language</h1>

      <p>The <code>EntityManager.createQuery</code> and <code>EntityManager.createNamedQuery</code> methods are used to query the datastore by using Java Persistence query language queries.</p>

      <p><a id="sthref1974"></a>The <code>createQuery</code> method is used to create <span class="glossaryterm">dynamic queries</span>, which are queries defined directly within an application's business logic:</p>
      <pre class="oac_no_warn" xml:space="preserve">
public List findWithName(String name) {
return em.createQuery(
    "SELECT c FROM Customer c WHERE c.name LIKE :custName")
    .setParameter("custName", name)
    .setMaxResults(10)
    .getResultList();
}
</pre>

      <p><a id="sthref1975"></a><a id="sthref1976"></a>The <code>createNamedQuery</code> method is used to create <span class="glossaryterm">static queries</span>, or queries that are defined in metadata by using the <code>javax.persistence.NamedQuery</code> annotation. The <code>name</code> element of <code>@NamedQuery</code> specifies the name of the query that will be used with the <code>createNamedQuery</code> method. The <code>query</code> element of <code>@NamedQuery</code> is the query:</p>
      <pre class="oac_no_warn" xml:space="preserve">
@NamedQuery(
    name="findAllCustomersWithName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
</pre>

      <p>Here's an example of <code>createNamedQuery</code>, which uses the <code>@NamedQuery</code>:</p>
      <pre class="oac_no_warn" xml:space="preserve">
@PersistenceContext
public EntityManager em;
...
customers = em.createNamedQuery("findAllCustomersWithName")
    .setParameter("custName", "Smith")
    .getResultList();
</pre><a id="BNBRH"></a><a id="JEETT01180"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_760"><span class="secnum">39.2.1</span> <a id="sthref1977"></a>Named Parameters in Queries</h2>

        <p>Named parameters are query parameters that are prefixed with a colon (<code>:</code>). Named parameters in a query are bound to an argument by the following method:</p>
        <pre class="oac_no_warn" xml:space="preserve">
javax.persistence.Query.setParameter(String name, Object value)
</pre>

        <p>In the following example, the <code>name</code> argument to the <code>findWithName</code> business method is bound to the <code>:custName</code> named parameter in the query by calling <code>Query.setParameter</code>:</p>
        <pre class="oac_no_warn" xml:space="preserve">
public List findWithName(String name) {
    return em.createQuery(
        "SELECT c FROM Customer c WHERE c.name LIKE :custName")
        .setParameter("custName", name)
        .getResultList();
}
</pre>

        <p>Named parameters are case-sensitive and may be used by both dynamic and static queries.</p>
      </div><a id="BNBRI"></a><a id="JEETT01181"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_761"><span class="secnum">39.2.2</span> <a id="sthref1978"></a>Positional Parameters in Queries</h2>

        <p>You may use positional parameters instead of named parameters in queries. Positional parameters are prefixed with a question mark (<code>?</code>) followed by the numeric position of the parameter in the query. The method <code>Query.setParameter(integer position, Object value)</code> is used to set the parameter values.</p>

        <p>In the following example, the <code>findWithName</code> business method is rewritten to use input parameters:</p>
        <pre class="oac_no_warn" xml:space="preserve">
public List findWithName(String name) {
    return em.createQuery(
        "SELECT c FROM Customer c WHERE c.name LIKE ?1")
        .setParameter(1, name)
        .getResultList();
}
</pre>

        <p>Input parameters are numbered starting from 1. Input parameters are case-sensitive, and may be used by both dynamic and static queries.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNBTI"></a><a id="JEETT00498"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_762"><span class="secnum">39.3</span> <a id="sthref1979"></a>Simplified Query Language Syntax</h1>

      <p>This section briefly describes the syntax of the query language so that you can quickly move on to <a href="../Text/persistence-querylanguage.xhtml#BNBTL">Example Queries</a>. When you are ready to learn about the syntax in more detail, see <a href="../Text/persistence-querylanguage.xhtml#BNBUF">Full Query Language Syntax</a>.</p><a id="BNBTJ"></a><a id="JEETT01182"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_763"><span class="secnum">39.3.1</span> Select Statements</h2>

        <p>A select query has six clauses: <code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code>, and <code>ORDER BY</code>. The <code>SELECT</code> and <code>FROM</code> clauses are required, but the <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code>, and <code>ORDER BY</code> clauses are optional. Here is the high-level BNF syntax of a query language select query:</p>
        <pre class="oac_no_warn" xml:space="preserve">
QL_statement ::= select_clause from_clause 
  [where_clause][groupby_clause][having_clause][orderby_clause]
</pre>

        <p>The BNF syntax defines the following clauses.</p>

        <ul>
          <li>
            <p><a id="sthref1980"></a>The <code>SELECT</code> clause defines the types of the objects or values returned by the query.</p>
          </li>

          <li>
            <p><a id="sthref1981"></a><a id="sthref1982"></a>The <code>FROM</code> clause defines the scope of the query by declaring one or more <span class="glossaryterm">identification variables</span>, which can be referenced in the <code>SELECT</code> and <code>WHERE</code> clauses. An identification variable represents one of the following elements:</p>

            <ul>
              <li>
                <p><a id="sthref1983"></a><a id="sthref1984"></a>The abstract schema name of an entity</p>
              </li>

              <li>
                <p>An element of a collection relationship</p>
              </li>

              <li>
                <p>An element of a single-valued relationship</p>
              </li>

              <li>
                <p>A member of a collection that is the multiple side of a one-to-many relationship</p>
              </li>
            </ul>
          </li>

          <li>
            <p><a id="sthref1985"></a>The <code>WHERE</code> clause is a conditional expression that restricts the objects or values retrieved by the query. Although the clause is optional, most queries have a <code>WHERE</code> clause.</p>
          </li>

          <li>
            <p><a id="sthref1986"></a>The <code>GROUP BY</code> clause groups query results according to a set of properties.</p>
          </li>

          <li>
            <p><a id="sthref1987"></a>The <code>HAVING</code> clause is used with the <code>GROUP BY</code> clause to further restrict the query results according to a conditional expression.</p>
          </li>

          <li>
            <p><a id="sthref1988"></a>The <code>ORDER BY</code> clause sorts the objects or values returned by the query into a specified order.</p>
          </li>
        </ul>
      </div><a id="BNBTK"></a><a id="JEETT01183"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_764"><span class="secnum">39.3.2</span> <a id="sthref1989"></a><a id="sthref1990"></a>Update and Delete Statements</h2>

        <p>Update and delete statements provide bulk operations over sets of entities. These statements have the following syntax:</p>
        <pre class="oac_no_warn" xml:space="preserve">
update_statement :: = update_clause [where_clause] 
delete_statement :: = delete_clause [where_clause]
</pre>

        <p>The update and delete clauses determine the type of the entities to be updated or deleted. The <code>WHERE</code> clause may be used to restrict the scope of the update or delete operation.</p>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNBTL"></a><a id="JEETT00499"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_765"><span class="secnum">39.4</span> <a id="sthref1991"></a><a id="sthref1992"></a>Example Queries</h1>

      <p>The following queries are from the <code>Player</code> entity of the <code>roster</code> application, which is documented in <a href="../Text/persistence-basicexamples.xhtml#GIQSQ">The roster Application</a>.</p><a id="BNBTM"></a><a id="JEETT01184"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_766"><span class="secnum">39.4.1</span> Simple Queries</h2>

        <p>If you are unfamiliar with the query language, these simple queries are a good place to start.</p><a id="BNBTN"></a><a id="JEETT00706"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.1.1</span> A Basic Select Query</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All players.</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: The <code>FROM</code> clause declares an identification variable named <code>p</code>, omitting the optional keyword <code>AS</code>. If the <code>AS</code> keyword were included, the clause would be written as follows:</p>
              <pre class="oac_no_warn" xml:space="preserve">
FROM Player AS p
</pre>

              <p>The <code>Player</code> element is the abstract schema name of the <code>Player</code> entity.</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBUM">Identification Variables</a>.</p>
            </li>
          </ul>
        </div><a id="BNBTO"></a><a id="JEETT00707"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.1.2</span> Eliminating Duplicate Values</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.position = ?1
</pre>

          <ul>
            <li>
              <p><a id="sthref1993"></a><span class="bold">Data retrieved</span>: The players with the position specified by the query's parameter.</p>
            </li>

            <li>
              <p><a id="sthref1994"></a><a id="sthref1995"></a><span class="bold">Description</span>: The <code>DISTINCT</code> keyword eliminates duplicate values.</p>

              <p>The <code>WHERE</code> clause restricts the players retrieved by checking their <code>position</code>, a persistent field of the <code>Player</code> entity. The <code>?1</code> element denotes the input parameter of the query.</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBVA">Input Parameters</a> and <a href="../Text/persistence-querylanguage.xhtml#BNBWB">The DISTINCT Keyword</a>.</p>
            </li>
          </ul>
        </div><a id="BNBTP"></a><a id="JEETT00708"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.1.3</span> Using Named Parameters</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.position = :position AND p.name = :name
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: The players having the specified positions and names.</p>
            </li>

            <li>
              <p><a id="sthref1996"></a><a id="sthref1997"></a><span class="bold">Description</span>: The <code>position</code> and <code>name</code> elements are persistent fields of the <code>Player</code> entity. The <code>WHERE</code> clause compares the values of these fields with the named parameters of the query, set using the <code>Query.setNamedParameter</code> method. The query language denotes a named input parameter using a colon (<code>:</code>) followed by an identifier. The first input parameter is <code>:position</code>, the second is <code>:name</code>.</p>
            </li>
          </ul>
        </div>
      </div><a id="BNBTQ"></a><a id="JEETT01185"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_767"><span class="secnum">39.4.2</span> <a id="sthref1998"></a>Queries That Navigate to Related Entities</h2>

        <p><a id="sthref1999"></a><a id="sthref2000"></a>In the query language, an expression can traverse, or navigate, to related entities. These expressions are the primary difference between the Java Persistence query language and SQL. Queries navigates to related entities, whereas SQL joins tables.</p><a id="BNBTR"></a><a id="JEETT00709"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.2.1</span> A Simple Query with Relationships</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p, IN (p.teams) t
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All players who belong to a team.</p>
            </li>

            <li>
              <p><a id="sthref2001"></a><a id="sthref2002"></a><span class="bold">Description</span>: The <code>FROM</code> clause declares two identification variables: <code>p</code> and <code>t</code>. The <code>p</code> variable represents the <code>Player</code> entity, and the <code>t</code> variable represents the related <code>Team</code> entity. The declaration for <code>t</code> references the previously declared <code>p</code> variable. The <code>IN</code> keyword signifies that <code>teams</code> is a collection of related entities. The <code>p.teams</code> expression navigates from a <code>Player</code> to its related <code>Team</code>. The period in the <code>p.teams</code> expression is the navigation operator.</p>

              <p><a id="sthref2003"></a>You may also use the <code>JOIN</code> statement to write the same query:</p>
              <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p JOIN p.teams t
</pre>

              <p>This query could also be rewritten as:</p>
              <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.team IS NOT EMPTY
</pre>
            </li>
          </ul>
        </div><a id="BNBTS"></a><a id="JEETT00710"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.2.2</span> Navigating to Single-Valued Relationship Fields</h3>

          <p><a id="sthref2004"></a>Use the <code>JOIN</code> clause statement to navigate to a single-valued relationship field:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Team t JOIN t.league l
WHERE l.sport = 'soccer' OR l.sport ='football'
</pre>

          <p>In this example, the query will return all teams that are in either soccer or football leagues.</p>
        </div><a id="BNBTT"></a><a id="JEETT00711"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.2.3</span> Traversing Relationships with an Input Parameter</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p, IN (p.teams) AS t
WHERE t.city = :city
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: The players whose teams belong to the specified city.</p>
            </li>

            <li>
              <p><a id="sthref2005"></a><a id="sthref2006"></a><span class="bold">Description</span>: This query is similar to the previous example but adds an input parameter. The <code>AS</code> keyword in the <code>FROM</code> clause is optional. In the <code>WHERE</code> clause, the period preceding the persistent variable <code>city</code> is a delimiter, not a navigation operator. Strictly speaking, expressions can navigate to relationship fields (related entities) but not to persistent fields. To access a persistent field, an expression uses the period as a delimiter.</p>

              <p>Expressions cannot navigate beyond (or further qualify) relationship fields that are collections. In the syntax of an expression, a collection-valued field is a terminal symbol. Because the <code>teams</code> field is a collection, the <code>WHERE</code> clause cannot specify <code>p.teams.city</code> (an illegal expression).</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBUQ">Path Expressions</a>.</p>
            </li>
          </ul>
        </div><a id="BNBTU"></a><a id="JEETT00712"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.2.4</span> Traversing Multiple Relationships</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p, IN (p.teams) t
WHERE t.league = :league
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: The players who belong to the specified league.</p>
            </li>

            <li>
              <p><a id="sthref2007"></a><span class="bold">Description</span>: The expressions in this query navigate over two relationships. The <code>p.teams</code> expression navigates the <code>Player</code>-<code>Team</code> relationship, and the <code>t.league</code> expression navigates the <code>Team</code>-<code>League</code> relationship.</p>
            </li>
          </ul>

          <p>In the other examples, the input parameters are <code>String</code> objects; in this example, the parameter is an object whose type is a <code>League</code>. This type matches the <code>league</code> relationship field in the comparison expression of the <code>WHERE</code> clause.</p>
        </div><a id="BNBTV"></a><a id="JEETT00713"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.2.5</span> Navigating According to Related Fields</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p, IN (p.teams) t
WHERE t.league.sport = :sport
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: The players who participate in the specified sport.</p>
            </li>

            <li>
              <p><a id="sthref2008"></a><span class="bold">Description</span>: The <code>sport</code> persistent field belongs to the <code>League</code> entity. To reach the <code>sport</code> field, the query must first navigate from the <code>Player</code> entity to <code>Team</code> (<code>p.teams</code>) and then from <code>Team</code> to the <code>League</code> entity (<code>t.league</code>). Because it is not a collection, the <code>league</code> relationship field can be followed by the <code>sport</code> persistent field.</p>
            </li>
          </ul>
        </div>
      </div><a id="BNBTW"></a><a id="JEETT01186"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_768"><span class="secnum">39.4.3</span> Queries with Other Conditional Expressions</h2>

        <p><a id="sthref2009"></a>Every <code>WHERE</code> clause must specify a conditional expression, of which there are several kinds. In the previous examples, the conditional expressions are comparison expressions that test for equality. The following examples demonstrate some of the other kinds of conditional expressions. For descriptions of all conditional expressions, see <a href="../Text/persistence-querylanguage.xhtml#BNBUU">WHERE Clause</a>.</p><a id="BNBTX"></a><a id="JEETT00714"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.3.1</span> <a id="sthref2010"></a>The LIKE Expression</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p
WHERE p.name LIKE 'Mich%'
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All players whose names begin with "Mich."</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: The <code>LIKE</code> expression uses wildcard characters to search for strings that match the wildcard pattern. In this case, the query uses the <code>LIKE</code> expression and the <code>%</code> wildcard to find all players whose names begin with the string "Mich." For example, "Michael" and "Michelle" both match the wildcard pattern.</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBVG">LIKE Expressions</a>.</p>
            </li>
          </ul>
        </div><a id="BNBTY"></a><a id="JEETT00715"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.3.2</span> <a id="sthref2011"></a>The IS NULL Expression</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Team t
WHERE t.league IS NULL
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All teams not associated with a league.</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: The <code>IS NULL</code> expression can be used to check whether a relationship has been set between two entities. In this case, the query checks whether the teams are associated with any leagues and returns the teams that do not have a league.</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBVI">NULL Comparison Expressions</a> and <a href="../Text/persistence-querylanguage.xhtml#BNBVR">NULL Values</a>.</p>
            </li>
          </ul>
        </div><a id="BNBTZ"></a><a id="JEETT00716"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.3.3</span> <a id="sthref2012"></a>The IS EMPTY Expression</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p
WHERE p.teams IS EMPTY
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All players who do not belong to a team.</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: The <code>teams</code> relationship field of the <code>Player</code> entity is a collection. If a player does not belong to a team, the <code>teams</code> collection is empty, and the conditional expression is <code>TRUE</code>.</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBVJ">Empty Collection Comparison Expressions</a>.</p>
            </li>
          </ul>
        </div><a id="BNBUA"></a><a id="JEETT00717"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.3.4</span> <a id="sthref2013"></a>The BETWEEN Expression</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.salary BETWEEN :lowerSalary AND :higherSalary
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: The players whose salaries fall within the range of the specified salaries.</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: This <code>BETWEEN</code> expression has three arithmetic expressions: a persistent field (<code>p.salary</code>) and the two input parameters (<code>:lowerSalary</code> and <code>:higherSalary</code>). The following expression is equivalent to the <code>BETWEEN</code> expression:</p>
              <pre class="oac_no_warn" xml:space="preserve">
p.salary &gt;= :lowerSalary AND p.salary &lt;= :higherSalary
</pre>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBVE">BETWEEN Expressions</a>.</p>
            </li>
          </ul>
        </div><a id="BNBUB"></a><a id="JEETT00718"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.3.5</span> <a id="sthref2014"></a>Comparison Operators</h3>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p1
FROM Player p1, Player p2
WHERE p1.salary &gt; p2.salary AND p2.name = :name
</pre>

          <ul>
            <li>
              <p><span class="bold">Data retrieved</span>: All players whose salaries are higher than the salary of the player with the specified name.</p>
            </li>

            <li>
              <p><span class="bold">Description</span>: The <code>FROM</code> clause declares two identification variables (<code>p1</code> and <code>p2</code>) of the same type (<code>Player</code>). Two identification variables are needed because the <code>WHERE</code> clause compares the salary of one player (<code>p2</code>) with that of the other players (<code>p1</code>).</p>
            </li>

            <li>
              <p><span class="bold">See also</span>: <a href="../Text/persistence-querylanguage.xhtml#BNBUM">Identification Variables</a>.</p>
            </li>
          </ul>
        </div>
      </div><a id="BNBUC"></a><a id="JEETT01187"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_769"><span class="secnum">39.4.4</span> Bulk Updates and Deletes</h2>

        <p><a id="sthref2015"></a><a id="sthref2016"></a>The following examples show how to use the <code>UPDATE</code> and <code>DELETE</code> expressions in queries. <code>UPDATE</code> and <code>DELETE</code> operate on multiple entities according to the condition or conditions set in the <code>WHERE</code> clause. The <code>WHERE</code> clause in <code>UPDATE</code> and <code>DELETE</code> queries follows the same rules as <code>SELECT</code> queries.</p><a id="BNBUD"></a><a id="JEETT00719"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.4.1</span> <a id="sthref2017"></a>Update Queries</h3>
          <pre class="oac_no_warn" xml:space="preserve">
UPDATE Player p
SET p.status = 'inactive'
WHERE p.lastPlayed &lt; :inactiveThresholdDate
</pre>

          <ul>
            <li>
              <p><span class="bold">Description</span>: This query sets the status of a set of players to <code>inactive</code> if the player's last game was longer ago than the date specified in <code>inactiveThresholdDate</code>.</p>
            </li>
          </ul>
        </div><a id="BNBUE"></a><a id="JEETT00720"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.4.4.2</span> <a id="sthref2018"></a>Delete Queries</h3>
          <pre class="oac_no_warn" xml:space="preserve">
DELETE
FROM Player p
WHERE p.status = 'inactive'
AND p.teams IS EMPTY
</pre>

          <ul>
            <li>
              <p><span class="bold">Description</span>: This query deletes all inactive players who are not on a team.</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="ind">
    <a id="BNBUF"></a><a id="JEETT00500"></a>

    <div class="sect1">
      <h1 class="sect1" id="sigil_toc_id_770"><span class="secnum">39.5</span> <a id="sthref2019"></a><a id="sthref2020"></a>Full Query Language Syntax</h1>

      <p>This section discusses the query language syntax, as defined in the Java Persistence API 2.0 specification available at <code><a href="../Text/http://jcp.org/en/jsr/detail?id=.xhtml#http://jcp.org/en/jsr/detail?id=317">http://jcp.org/en/jsr/detail?id=317</a></code>. Much of the following material paraphrases or directly quotes the specification.</p><a id="BNBUG"></a><a id="JEETT01188"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_771"><span class="secnum">39.5.1</span> BNF Symbols</h2>

        <p><a href="../Text/persistence-querylanguage.xhtml#BNBUH">Table 39-1</a> describes the BNF symbols used in this chapter.</p>

        <div class="tblhruleformal">
          <a id="sthref2021"></a><a id="BNBUH"></a>

          <p class="titleintable">Table 39-1 BNF Symbol Summary</p>

          <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and describes the BNF symbols used in this chapter." title="BNF Symbol Summary" width="100%">
            <col width="17%" />
            <col width="*" />

            <thead>
              <tr align="left" valign="top">
                <th align="left" id="r1c1-t2" valign="bottom">Symbol</th>

                <th align="left" id="r1c2-t2" valign="bottom">Description</th>
              </tr>
            </thead>

            <tbody>
              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r2c1-t2">
                  <p><code>::=</code></p>
                </td>

                <td align="left" headers="r2c1-t2 r1c2-t2">
                  <p>The element to the left of the symbol is defined by the constructs on the right.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r3c1-t2">
                  <p><code>*</code></p><br />
                </td>

                <td align="left" headers="r3c1-t2 r1c2-t2">
                  <p>The preceding construct may occur zero or more times.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r4c1-t2">
                  <p><code>{...}</code></p>
                </td>

                <td align="left" headers="r4c1-t2 r1c2-t2">
                  <p>The constructs within the braces are grouped together.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r5c1-t2">
                  <p><code>[...]</code></p>
                </td>

                <td align="left" headers="r5c1-t2 r1c2-t2">
                  <p>The constructs within the brackets are optional.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r6c1-t2">
                  <p><code>|</code></p><br />
                </td>

                <td align="left" headers="r6c1-t2 r1c2-t2">
                  <p>An exclusive <code>OR</code>.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r7c1-t2">
                  <p><code>BOLDFACE</code></p>
                </td>

                <td align="left" headers="r7c1-t2 r1c2-t2">
                  <p>A keyword; although capitalized in the BNF diagram, keywords are not case-sensitive.</p>
                </td>
              </tr>

              <tr align="left" valign="top">
                <td align="left" headers="r1c1-t2" id="r8c1-t2">
                  <p>White space</p>
                </td>

                <td align="left" headers="r8c1-t2 r1c2-t2">
                  <p>A whitespace character can be a space, a horizontal tab, or a line feed.</p>
                </td>
              </tr>
            </tbody>
          </table><br />
        </div>
      </div><a id="BNBUI"></a><a id="JEETT01189"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_772"><span class="secnum">39.5.2</span> BNF Grammar of the Java Persistence Query Language</h2>

        <p>Here is the entire BNF diagram for the query language:</p>
        <pre class="oac_no_warn" xml:space="preserve">
QL_statement ::= select_statement | update_statement | delete_statement
select_statement ::= select_clause from_clause [where_clause] [groupby_clause] 
    [having_clause] [orderby_clause]
update_statement ::= update_clause [where_clause]
delete_statement ::= delete_clause [where_clause]
from_clause ::=
    FROM identification_variable_declaration
        {, {identification_variable_declaration |
            collection_member_declaration}}*
identification_variable_declaration ::=
        range_variable_declaration { join | fetch_join }*
range_variable_declaration ::= abstract_schema_name [AS]
        identification_variable
join ::= join_spec join_association_path_expression [AS]
        identification_variable
fetch_join ::= join_specFETCH join_association_path_expression
association_path_expression ::=
        collection_valued_path_expression |
        single_valued_association_path_expression
join_spec::= [LEFT [OUTER] |INNER] JOIN
join_association_path_expression ::=
        join_collection_valued_path_expression |
        join_single_valued_association_path_expression
join_collection_valued_path_expression::=
    identification_variable.collection_valued_association_field
join_single_valued_association_path_expression::=
        identification_variable.single_valued_association_field
collection_member_declaration ::=
        IN (collection_valued_path_expression) [AS]
        identification_variable
single_valued_path_expression ::=
        state_field_path_expression |
        single_valued_association_path_expression
state_field_path_expression ::=
    {identification_variable |
    single_valued_association_path_expression}.state_field
single_valued_association_path_expression ::=
    identification_variable.{single_valued_association_field.}*
    single_valued_association_field
collection_valued_path_expression ::=
    identification_variable.{single_valued_association_field.}*
    collection_valued_association_field
state_field ::=
    {embedded_class_state_field.}*simple_state_field
update_clause ::=UPDATE abstract_schema_name [[AS]
    identification_variable] SET update_item {, update_item}*
update_item ::= [identification_variable.]{state_field |
    single_valued_association_field} = new_value
new_value ::=
     simple_arithmetic_expression |
    string_primary |
    datetime_primary |
    boolean_primary |
    enum_primary simple_entity_expression |
    NULL
delete_clause ::= DELETE FROM abstract_schema_name [[AS]
    identification_variable]
select_clause ::= SELECT [DISTINCT] select_expression {,
    select_expression}*
select_expression ::=
    single_valued_path_expression |
    aggregate_expression |
    identification_variable |
    OBJECT(identification_variable) |
    constructor_expression
constructor_expression ::=
    NEW constructor_name(constructor_item {,
    constructor_item}*)
constructor_item ::= single_valued_path_expression |
    aggregate_expression
aggregate_expression ::=
    {AVG |MAX |MIN |SUM} ([DISTINCT]
        state_field_path_expression) |
    COUNT ([DISTINCT] identification_variable |
        state_field_path_expression |
        single_valued_association_path_expression)
where_clause ::= WHERE conditional_expression
groupby_clause ::= GROUP BY groupby_item {, groupby_item}*
groupby_item ::= single_valued_path_expression
having_clause ::= HAVING conditional_expression
orderby_clause ::= ORDER BY orderby_item {, orderby_item}*
orderby_item ::= state_field_path_expression [ASC |DESC]
subquery ::= simple_select_clause subquery_from_clause
    [where_clause] [groupby_clause] [having_clause]
subquery_from_clause ::=
    FROM subselect_identification_variable_declaration
        {, subselect_identification_variable_declaration}*
subselect_identification_variable_declaration ::=
    identification_variable_declaration |
    association_path_expression [AS] identification_variable |
    collection_member_declaration
simple_select_clause ::= SELECT [DISTINCT]
    simple_select_expression
simple_select_expression::=
    single_valued_path_expression |
    aggregate_expression |
    identification_variable
conditional_expression ::= conditional_term |
    conditional_expression OR conditional_term
conditional_term ::= conditional_factor | conditional_term AND
    conditional_factor
conditional_factor ::= [NOT] conditional_primary
conditional_primary ::= simple_cond_expression |(
    conditional_expression)
simple_cond_expression ::=
    comparison_expression |
    between_expression |
    like_expression |
    in_expression |
    null_comparison_expression |
    empty_collection_comparison_expression |
    collection_member_expression |
    exists_expression
between_expression ::=
    arithmetic_expression [NOT] BETWEEN
        arithmetic_expressionAND arithmetic_expression |
    string_expression [NOT] BETWEEN string_expression AND
        string_expression |
    datetime_expression [NOT] BETWEEN
        datetime_expression AND datetime_expression
in_expression ::=
    state_field_path_expression [NOT] IN (in_item {, in_item}*
    | subquery)
in_item ::= literal | input_parameter
like_expression ::=
    string_expression [NOT] LIKE pattern_value [ESCAPE
        escape_character]
null_comparison_expression ::=
    {single_valued_path_expression | input_parameter} IS [NOT]
        NULL
empty_collection_comparison_expression ::=
    collection_valued_path_expression IS [NOT] EMPTY
collection_member_expression ::= entity_expression
    [NOT] MEMBER [OF] collection_valued_path_expression
exists_expression::= [NOT] EXISTS (subquery)
all_or_any_expression ::= {ALL |ANY |SOME} (subquery)
comparison_expression ::=
    string_expression comparison_operator {string_expression |
    all_or_any_expression} |
    boolean_expression {= |&lt;&gt; } {boolean_expression |
    all_or_any_expression} |
    enum_expression {= |&lt;&gt; } {enum_expression |
    all_or_any_expression} |
    datetime_expression comparison_operator
        {datetime_expression | all_or_any_expression} |
    entity_expression {= |&lt;&gt; } {entity_expression |
    all_or_any_expression} |
    arithmetic_expression comparison_operator
        {arithmetic_expression | all_or_any_expression}
comparison_operator ::= = |&gt; |&gt;= |&lt; |&lt;= |&lt;&gt;
arithmetic_expression ::= simple_arithmetic_expression |
    (subquery)
simple_arithmetic_expression ::=
    arithmetic_term | simple_arithmetic_expression {+ |- }
        arithmetic_term
arithmetic_term ::= arithmetic_factor | arithmetic_term {* |/ }
    arithmetic_factor
arithmetic_factor ::= [{+ |- }] arithmetic_primary
arithmetic_primary ::=
    state_field_path_expression |
    numeric_literal |
    (simple_arithmetic_expression) |
    input_parameter |
    functions_returning_numerics |
    aggregate_expression
string_expression ::= string_primary | (subquery)
string_primary ::=
    state_field_path_expression |
    string_literal |
    input_parameter |
    functions_returning_strings |
    aggregate_expression
datetime_expression ::= datetime_primary | (subquery)
datetime_primary ::=
    state_field_path_expression |
    input_parameter |
    functions_returning_datetime |
    aggregate_expression
boolean_expression ::= boolean_primary | (subquery)
boolean_primary ::=
    state_field_path_expression |
    boolean_literal |
    input_parameter
 enum_expression ::= enum_primary | (subquery)
enum_primary ::=
    state_field_path_expression |
    enum_literal |
    input_parameter
entity_expression ::=
    single_valued_association_path_expression |
        simple_entity_expression
simple_entity_expression ::=
    identification_variable |
    input_parameter
functions_returning_numerics::=
    LENGTH(string_primary) |
    LOCATE(string_primary, string_primary[,
        simple_arithmetic_expression]) |
    ABS(simple_arithmetic_expression) |
    SQRT(simple_arithmetic_expression) |
    MOD(simple_arithmetic_expression,
        simple_arithmetic_expression) |
    SIZE(collection_valued_path_expression)
functions_returning_datetime ::=
    CURRENT_DATE |
    CURRENT_TIME |
    CURRENT_TIMESTAMP
functions_returning_strings ::=
    CONCAT(string_primary, string_primary) |
    SUBSTRING(string_primary,
        simple_arithmetic_expression,
        simple_arithmetic_expression)|
    TRIM([[trim_specification] [trim_character] FROM]
        string_primary) |
    LOWER(string_primary) |
    UPPER(string_primary)
trim_specification ::= LEADING | TRAILING | BOTH
</pre>
      </div><a id="BNBUJ"></a><a id="JEETT01190"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_773"><span class="secnum">39.5.3</span> <a id="sthref2022"></a>FROM Clause</h2>

        <p><a id="sthref2023"></a><a id="sthref2024"></a>The <code>FROM</code> clause defines the domain of the query by declaring identification variables.</p><a id="BNBUK"></a><a id="JEETT00721"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.3.1</span> <a id="sthref2025"></a>Identifiers</h3>

          <p>An identifier is a sequence of one or more characters. The first character must be a valid first character (letter, <code>$</code>, <code>_</code>) in an identifier of the Java programming language, hereafter in this chapter called simply "Java." Each subsequent character in the sequence must be a valid nonfirst character (letter, digit, <code>$</code>, <code>_</code>) in a Java identifier. (For details, see the Java SE API documentation of the <code>isJavaIdentifierStart</code> and <code>isJavaIdentifierPart</code> methods of the <code>Character</code> class.) The question mark (<code>?</code>) is a reserved character in the query language and cannot be used in an identifier.</p>

          <p>A query language identifier is case-sensitive, with two exceptions:</p>

          <ul>
            <li>
              <p>Keywords</p>
            </li>

            <li>
              <p>Identification variables</p>
            </li>
          </ul>

          <p>An identifier cannot be the same as a query language keyword. Here is a list of query language keywords:</p><br />
          <code>ABS</code><br />
          <code>ALL</code><br />
          <code>AND</code><br />
          <code>ANY</code><br />
          <code>AS</code><br />
          <code>ASC</code><br />
          <code>AVG</code><br />
          <code>BETWEEN</code><br />
          <code>BIT_LENGTH</code><br />
          <code>BOTH</code><br />
          <code>BY</code><br />
          <code>CASE</code><br />
          <code>CHAR_LENGTH</code><br />
          <code>CHARACTER_LENGTH</code><br />
          <code>CLASS</code><br />
          <code>COALESCE</code><br />
          <code>CONCAT</code><br />
          <code>COUNT</code><br />
          <code>CURRENT_DATE</code><br />
          <code>CURRENT_TIMESTAMP</code><br />
          <code>DELETE</code><br />
          <code>DESC</code><br />
          <code>DISTINCT</code><br />
          <code>ELSE</code><br />
          <code>EMPTY</code><br />
          <code>END</code><br />
          <code>ENTRY</code><br />
          <code>ESCAPE</code><br />
          <code>EXISTS</code><br />
          <code>FALSE</code><br />
          <code>FETCH</code><br />
          <code>FROM</code><br />
          <code>GROUP</code><br />
          <code>HAVING</code><br />
          <code>IN</code><br />
          <code>INDEX</code><br />
          <code>INNER</code><br />
          <code>IS</code><br />
          <code>JOIN</code><br />
          <code>KEY</code><br />
          <code>LEADING</code><br />
          <code>LEFT</code><br />
          <code>LENGTH</code><br />
          <code>LIKE</code><br />
          <code>LOCATE</code><br />
          <code>LOWER</code><br />
          <code>MAX</code><br />
          <code>MEMBER</code><br />
          <code>MIN</code><br />
          <code>MOD</code><br />
          <code>NEW</code><br />
          <code>NOT</code><br />
          <code>NULL</code><br />
          <code>NULLIF</code><br />
          <code>OBJECT</code><br />
          <code>OF</code><br />
          <code>OR</code><br />
          <code>ORDER</code><br />
          <code>OUTER</code><br />
          <code>POSITION</code><br />
          <code>SELECT</code><br />
          <code>SET</code><br />
          <code>SIZE</code><br />
          <code>SOME</code><br />
          <code>SQRT</code><br />
          <code>SUBSTRING</code><br />
          <code>SUM</code><br />
          <code>THEN</code><br />
          <code>TRAILING</code><br />
          <code>TRIM</code><br />
          <code>TRUE</code><br />
          <code>TYPE</code><br />
          <code>UNKNOWN</code><br />
          <code>UPDATE</code><br />
          <code>UPPER</code><br />
          <code>VALUE</code><br />
          <code>WHEN</code><br />
          <code>WHERE</code><br />

          <p><a id="sthref2026"></a><a id="sthref2027"></a>It is not recommended that you use an SQL keyword as an identifier, because the list of keywords may expand to include other reserved SQL words in the future.</p>
        </div><a id="BNBUM"></a><a id="JEETT00722"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.3.2</span> <a id="sthref2028"></a>Identification Variables</h3>

          <p>An identification variable is an identifier declared in the <code>FROM</code> clause. Although they can reference identification variables, the <code>SELECT</code> and <code>WHERE</code> clauses cannot declare them. All identification variables must be declared in the <code>FROM</code> clause.</p>

          <p><a id="sthref2029"></a>Because it is an identifier, an identification variable has the same naming conventions and restrictions as an identifier, with the exception that an identification variable is case-insensitive. For example, an identification variable cannot be the same as a query language keyword. (See <a href="../Text/persistence-querylanguage.xhtml#BNBUK">Identifiers</a> for more naming rules.) Also, within a given persistence unit, an identification variable name must not match the name of any entity or abstract schema.</p>

          <p><a id="sthref2030"></a>The <code>FROM</code> clause can contain multiple declarations, separated by commas. A declaration can reference another identification variable that has been previously declared (to the left). In the following <code>FROM</code> clause, the variable <code>t</code> references the previously declared variable <code>p</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player p, IN (p.teams) AS t
</pre>

          <p><a id="sthref2031"></a>Even if it is not used in the <code>WHERE</code> clause, an identification variable's declaration can affect the results of the query. For example, compare the next two queries. The following query returns all players, whether or not they belong to a team:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p
</pre>

          <p>In contrast, because it declares the <code>t</code> identification variable, the next query fetches all players who belong to a team:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p, IN (p.teams) AS t
</pre>

          <p>The following query returns the same results as the preceding query, but the <code>WHERE</code> clause makes it easier to read:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p
FROM Player p
WHERE p.teams IS NOT EMPTY
</pre>

          <p>An identification variable always designates a reference to a single value whose type is that of the expression used in the declaration. There are two kinds of declarations: range variable and collection member.</p>
        </div><a id="BNBUN"></a><a id="JEETT00723"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.3.3</span> <a id="sthref2032"></a>Range Variable Declarations</h3>

          <p><a id="sthref2033"></a>To declare an identification variable as an abstract schema type, you specify a range variable declaration. In other words, an identification variable can range over the abstract schema type of an entity. In the following example, an identification variable named <code>p</code> represents the abstract schema named <code>Player</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player p
</pre>

          <p>A range variable declaration can include the optional <code>AS</code> operator:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player AS p
</pre>

          <p><a id="sthref2034"></a><a id="sthref2035"></a>To obtain objects, a query usually uses path expressions to navigate through the relationships. But for those objects that cannot be obtained by navigation, you can use a range variable declaration to designate a starting point, or query root.</p>

          <p>If the query compares multiple values of the same abstract schema type, the <code>FROM</code> clause must declare multiple identification variables for the abstract schema:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player p1, Player p2
</pre>

          <p>For an example of such a query, see <a href="../Text/persistence-querylanguage.xhtml#BNBUB">Comparison Operators</a>.</p>
        </div><a id="BNBUO"></a><a id="JEETT00724"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.3.4</span> <a id="sthref2036"></a><a id="sthref2037"></a>Collection Member Declarations</h3>

          <p><a id="sthref2038"></a>In a one-to-many relationship, the multiple side consists of a collection of entities. An identification variable can represent a member of this collection. To access a collection member, the path expression in the variable's declaration navigates through the relationships in the abstract schema. (For more information on path expressions, see <a href="../Text/persistence-querylanguage.xhtml#BNBUQ">Path Expressions</a>.) Because a path expression can be based on another path expression, the navigation can traverse several relationships. See <a href="../Text/persistence-querylanguage.xhtml#BNBTU">Traversing Multiple Relationships</a>.</p>

          <p>A collection member declaration must include the <code>IN</code> operator but can omit the optional <code>AS</code> operator.</p>

          <p>In the following example, the entity represented by the abstract schema named <code>Player</code> has a relationship field called <code>teams</code>. The identification variable called <code>t</code> represents a single member of the <code>teams</code> collection:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player p, IN (p.teams) t
</pre>
        </div><a id="BNBUP"></a><a id="JEETT00725"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.3.5</span> <a id="sthref2039"></a>Joins</h3>

          <p>The <code>JOIN</code> operator is used to traverse over relationships between entities and is functionally similar to the <code>IN</code> operator.</p>

          <p>In the following example, the query joins over the relationship between customers and orders:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c
FROM Customer c JOIN c.orders o
WHERE c.status = 1 AND o.totalPrice &gt; 10000
</pre>

          <p><a id="sthref2040"></a>The <code>INNER</code> keyword is optional:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c
FROM Customer c INNER JOIN c.orders o
WHERE c.status = 1 AND o.totalPrice &gt; 10000
</pre>

          <p><a id="sthref2041"></a>These examples are equivalent to the following query, which uses the <code>IN</code> operator:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c
FROM Customer c, IN (c.orders) o
WHERE c.status = 1 AND o.totalPrice &gt; 10000
</pre>

          <p>You can also join a single-valued relationship:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Team t JOIN t.league l
WHERE l.sport = :sport
</pre>

          <p><a id="sthref2042"></a><a id="sthref2043"></a>A <code>LEFT JOIN</code> or <code>LEFT OUTER JOIN</code> retrieves a set of entities where matching values in the join condition may be absent. The <code>OUTER</code> keyword is optional:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c.name, o.totalPrice
FROM CustomerOrder o LEFT JOIN o.customer c
</pre>

          <p><a id="sthref2044"></a>A <code>FETCH JOIN</code> is a join operation that returns associated entities as a side effect of running the query. In the following example, the query returns a set of departments and, as a side effect, the associated employees of the departments, even though the employees were not explicitly retrieved by the <code>SELECT</code> clause:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT d
FROM Department d LEFT JOIN FETCH d.employees
WHERE d.deptno = 1
</pre>
        </div>
      </div><a id="BNBUQ"></a><a id="JEETT01191"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_774"><span class="secnum">39.5.4</span> <a id="sthref2045"></a>Path Expressions</h2>

        <p><a id="sthref2046"></a><a id="sthref2047"></a>Path expressions are important constructs in the syntax of the query language for several reasons. First, path expressions define navigation paths through the relationships in the abstract schema. These path definitions affect both the scope and the results of a query. Second, path expressions can appear in any of the main clauses of a query (<code>SELECT</code>, <code>DELETE</code>, <code>HAVING</code>, <code>UPDATE</code>, <code>WHERE</code>, <code>FROM</code>, <code>GROUP BY</code>, <code>ORDER BY</code>). Finally, although much of the query language is a subset of SQL, path expressions are extensions not found in SQL.</p><a id="BNBUR"></a><a id="JEETT00726"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.4.1</span> Examples of Path Expressions</h3>

          <p>Here, the <code>WHERE</code> clause contains a <code>single_valued_path_expression</code>; the <code>p</code> is an identification variable, and <code>salary</code> is a persistent field of <code>Player</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.salary BETWEEN :lowerSalary AND :higherSalary
</pre>

          <p>Here, the <code>WHERE</code> clause also contains a <code>single_valued_path_expression</code>; <code>t</code> is an identification variable, <code>league</code> is a single-valued relationship field, and <code>sport</code> is a persistent field of <code>league</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p, IN (p.teams) t
WHERE t.league.sport = :sport
</pre>

          <p>Here, the <code>WHERE</code> clause contains a <code>collection_valued_path_expression</code>; <code>p</code> is an identification variable, and <code>teams</code> designates a collection-valued relationship field:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT p
FROM Player p
WHERE p.teams IS EMPTY
</pre>
        </div><a id="BNBUS"></a><a id="JEETT00727"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.4.2</span> <a id="sthref2048"></a>Expression Types</h3>

          <p>The type of a path expression is the type of the object represented by the ending element, which can be one of the following:</p>

          <ul>
            <li>
              <p>Persistent field</p>
            </li>

            <li>
              <p>Single-valued relationship field</p>
            </li>

            <li>
              <p>Collection-valued relationship field</p>
            </li>
          </ul>

          <p>For example, the type of the expression <code>p.salary</code> is <code>double</code> because the terminating persistent field (<code>salary</code>) is a <code>double</code>.</p>

          <p>In the expression <code>p.teams</code>, the terminating element is a collection-valued relationship field (<code>teams</code>). This expression's type is a collection of the abstract schema type named <code>Team</code>. Because <code>Team</code> is the abstract schema name for the <code>Team</code> entity, this type maps to the entity. For more information on the type mapping of abstract schemas, see <a href="../Text/persistence-querylanguage.xhtml#BNBVY">Return Types</a>.</p>
        </div><a id="BNBUT"></a><a id="JEETT00728"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.4.3</span> <a id="sthref2049"></a>Navigation</h3>

          <p>A path expression enables the query to navigate to related entities. The terminating elements of an expression determine whether navigation is allowed. If an expression contains a single-valued relationship field, the navigation can continue to an object that is related to the field. However, an expression cannot navigate beyond a persistent field or a collection-valued relationship field. For example, the expression <code>p.teams.league.sport</code> is illegal because <code>teams</code> is a collection-valued relationship field. To reach the <code>sport</code> field, the <code>FROM</code> clause could define an identification variable named <code>t</code> for the <code>teams</code> field:</p>
          <pre class="oac_no_warn" xml:space="preserve">
FROM Player AS p, IN (p.teams) t
WHERE t.league.sport = 'soccer'
</pre>
        </div>
      </div><a id="BNBUU"></a><a id="JEETT01192"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_775"><span class="secnum">39.5.5</span> <a id="sthref2050"></a>WHERE Clause</h2>

        <p><a id="sthref2051"></a>The <code>WHERE</code> clause specifies a conditional expression that limits the values returned by the query. The query returns all corresponding values in the data store for which the conditional expression is <code>TRUE</code>. Although usually specified, the <code>WHERE</code> clause is optional. If the <code>WHERE</code> clause is omitted, the query returns all values. The high-level syntax for the <code>WHERE</code> clause is as follows:</p>
        <pre class="oac_no_warn" xml:space="preserve">
where_clause ::= WHERE conditional_expression
</pre><a id="BNBUV"></a><a id="JEETT00729"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.1</span> <a id="sthref2052"></a>Literals</h3>

          <p>There are four kinds of literals: string, numeric, Boolean, and enum.</p>

          <ul>
            <li>
              <p><a id="sthref2053"></a><span class="bold">String literals</span>: A string literal is enclosed in single quotes:</p>
              <pre class="oac_no_warn" xml:space="preserve">
'Duke'
</pre>

              <p>If a string literal contains a single quote, you indicate the quote by using two single quotes:</p>
              <pre class="oac_no_warn" xml:space="preserve">
'Duke''s'
</pre>

              <p>Like a Java <code>String</code>, a string literal in the query language uses the Unicode character encoding.</p>
            </li>

            <li>
              <p><a id="sthref2054"></a><span class="bold">Numeric literals</span>: There are two types of numeric literals: exact and approximate.</p>

              <ul>
                <li>
                  <p>An exact numeric literal is a numeric value without a decimal point, such as 65, &ndash;233, and +12. Using the Java integer syntax, exact numeric literals support numbers in the range of a Java <code>long</code>.</p>
                </li>

                <li>
                  <p>An approximate numeric literal is a numeric value in scientific notation, such as 57., &ndash;85.7, and +2.1. Using the syntax of the Java floating-point literal, approximate numeric literals support numbers in the range of a Java <code>double</code>.</p>
                </li>
              </ul>
            </li>

            <li>
              <p><a id="sthref2055"></a><span class="bold">Boolean literals</span>: A Boolean literal is either <code>TRUE</code> or <code>FALSE</code>. These keywords are not case-sensitive.</p>
            </li>

            <li>
              <p><a id="sthref2056"></a><span class="bold">Enum literals</span>: The Java Persistence query language supports the use of enum literals using the Java enum literal syntax. The enum class name must be specified as a fully qualified class name:</p>
              <pre class="oac_no_warn" xml:space="preserve">
SELECT e
FROM Employee e
WHERE e.status = com.example.EmployeeStatus.FULL_TIME
</pre>
            </li>
          </ul>
        </div><a id="BNBVA"></a><a id="JEETT00730"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.2</span> <a id="sthref2057"></a>Input Parameters</h3>

          <p><a id="sthref2058"></a><a id="sthref2059"></a>An input parameter can be either a named parameter or a positional parameter.</p>

          <ul>
            <li>
              <p>A named input parameter is designated by a colon (<code>:</code>) followed by a string; for example, <code>:name</code>.</p>
            </li>

            <li>
              <p>A positional input parameter is designated by a question mark (<code>?</code>) followed by an integer. For example, the first input parameter is <code>?1</code>, the second is <code>?2</code>, and so forth.</p>
            </li>
          </ul>

          <p>The following rules apply to input parameters.</p>

          <ul>
            <li>
              <p>They can be used only in a <code>WHERE</code> or <code>HAVING</code> clause.</p>
            </li>

            <li>
              <p>Positional parameters must be numbered, starting with the integer 1.</p>
            </li>

            <li>
              <p>Named parameters and positional parameters may not be mixed in a single query.</p>
            </li>

            <li>
              <p>Named parameters are case-sensitive.</p>
            </li>
          </ul>
        </div><a id="BNBVB"></a><a id="JEETT00731"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.3</span> <a id="sthref2060"></a>Conditional Expressions</h3>

          <p><a id="sthref2061"></a>A <code>WHERE</code> clause consists of a conditional expression, which is evaluated from left to right within a precedence level. You can change the order of evaluation by using parentheses.</p>
        </div><a id="BNBVC"></a><a id="JEETT00732"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.4</span> <a id="sthref2062"></a><a id="sthref2063"></a>Operators and Their Precedence</h3>

          <p><a href="../Text/persistence-querylanguage.xhtml#BNBVD">Table 39-2</a> lists the query language operators in order of decreasing precedence.</p>

          <div class="tblhruleformal">
            <a id="sthref2064"></a><a id="BNBVD"></a>

            <p class="titleintable">Table 39-2 Query Language Order Precedence</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and categorizes the query language operators in order of precedence." title="Query Language Order Precedence" width="100%">
              <col width="21%" />
              <col width="*" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t3" valign="bottom">Type</th>

                  <th align="left" id="r1c2-t3" valign="bottom">Precedence Order</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r2c1-t3">
                    <p>Navigation</p>
                  </td>

                  <td align="left" headers="r2c1-t3 r1c2-t3">
                    <p><code>.</code> (a period)</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r3c1-t3">
                    <p>Arithmetic</p>
                  </td>

                  <td align="left" headers="r3c1-t3 r1c2-t3">
                    <p><code>+ &ndash;</code> (unary)</p>

                    <p><code>* /</code> (multiplication and division)</p>

                    <p><code>+ &ndash;</code> (addition and subtraction)</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r4c1-t3">
                    <p>Comparison</p>
                  </td>

                  <td align="left" headers="r4c1-t3 r1c2-t3">
                    <p><code>=</code></p>

                    <p><code>&gt;</code></p>

                    <p><code>&gt;=</code></p>

                    <p><code>&lt;</code></p>

                    <p><code>&lt;=</code></p>

                    <p><code>&lt;&gt;</code> (not equal)</p>

                    <p><code>[NOT] BETWEEN</code></p>

                    <p><code>[NOT] LIKE</code></p>

                    <p><code>[NOT] IN</code></p>

                    <p><code>IS [NOT] NULL</code></p>

                    <p><code>IS [NOT] EMPTY</code></p>

                    <p><code>[NOT] MEMBER OF</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t3" id="r5c1-t3">
                    <p>Logical</p>
                  </td>

                  <td align="left" headers="r5c1-t3 r1c2-t3">
                    <p><code>NOT</code></p>

                    <p><code>AND</code></p>

                    <p><code>OR</code></p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div><a id="BNBVE"></a><a id="JEETT00733"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.5</span> <a id="sthref2065"></a>BETWEEN Expressions</h3>

          <p><a id="sthref2066"></a>A <code>BETWEEN</code> expression determines whether an arithmetic expression falls within a range of values.</p>

          <p>These two expressions are equivalent:</p>
          <pre class="oac_no_warn" xml:space="preserve">
p.age BETWEEN 15 AND 19
p.age &gt;= 15 AND p.age &lt;= 19
</pre>

          <p>The following two expressions also are equivalent:</p>
          <pre class="oac_no_warn" xml:space="preserve">
p.age NOT BETWEEN 15 AND 19
p.age &lt; 15 OR p.age &gt; 19
</pre>

          <p>If an arithmetic expression has a <code>NULL</code> value, the value of the <code>BETWEEN</code> expression is unknown.</p>
        </div><a id="BNBVF"></a><a id="JEETT00734"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.6</span> <a id="sthref2067"></a>IN Expressions</h3>

          <p>An <code>IN</code> expression determines whether a string belongs to a set of string literals or whether a number belongs to a set of number values.</p>

          <p>The path expression must have a string or numeric value. If the path expression has a <code>NULL</code> value, the value of the <code>IN</code> expression is unknown.</p>

          <p>In the following example, the expression is <code>TRUE</code> if the country is <code>UK</code> , but <code>FALSE</code> if the country is <code>Peru</code>:</p>
          <pre class="oac_no_warn" xml:space="preserve">
o.country IN ('UK', 'US', 'France')
</pre>

          <p>You may also use input parameters:</p>
          <pre class="oac_no_warn" xml:space="preserve">
o.country IN ('UK', 'US', 'France', :country)
</pre>
        </div><a id="BNBVG"></a><a id="JEETT00735"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.7</span> <a id="sthref2068"></a>LIKE Expressions</h3>

          <p><a id="sthref2069"></a>A <code>LIKE</code> expression determines whether a wildcard pattern matches a string.</p>

          <p><a id="sthref2070"></a>The path expression must have a string or numeric value. If this value is <code>NULL</code>, the value of the <code>LIKE</code> expression is unknown. The pattern value is a string literal that can contain wildcard characters. The underscore (<code>_</code>) wildcard character represents any single character. The percent (<code>%</code>) wildcard character represents zero or more characters. The <code>ESCAPE</code> clause specifies an escape character for the wildcard characters in the pattern value. <a href="../Text/persistence-querylanguage.xhtml#BNBVH">Table 39-3</a> shows some sample <code>LIKE</code> expressions.</p>

          <div class="tblhruleformal">
            <a id="sthref2071"></a><a id="BNBVH"></a>

            <p class="titleintable">Table 39-3 LIKE Expression Examples</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table provides examples of true and false LIKE expressions." title="LIKE Expression Examples" width="100%">
              <col width="*" />
              <col width="21%" />
              <col width="22%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t4" valign="bottom">Expression</th>

                  <th align="left" id="r1c2-t4" valign="bottom">TRUE</th>

                  <th align="left" id="r1c3-t4" valign="bottom">FALSE</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t4" id="r2c1-t4">
                    <p><code>address.phone LIKE '12%3'</code></p>
                  </td>

                  <td align="left" headers="r2c1-t4 r1c2-t4">
                    <p><code>'123'</code></p>

                    <p><code>'12993'</code></p>
                  </td>

                  <td align="left" headers="r2c1-t4 r1c3-t4">
                    <p><code>'1234'</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t4" id="r3c1-t4">
                    <p><code>asentence.word LIKE 'l_se'</code></p>
                  </td>

                  <td align="left" headers="r3c1-t4 r1c2-t4">
                    <p><code>'lose'</code></p>
                  </td>

                  <td align="left" headers="r3c1-t4 r1c3-t4">
                    <p><code>'loose'</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t4" id="r4c1-t4">
                    <p><code>aword.underscored LIKE '\_%' ESCAPE '\'</code></p>
                  </td>

                  <td align="left" headers="r4c1-t4 r1c2-t4">
                    <p><code>'_foo'</code></p>
                  </td>

                  <td align="left" headers="r4c1-t4 r1c3-t4">
                    <p><code>'bar'</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t4" id="r5c1-t4">
                    <p><code>address.phone NOT LIKE '12%3'</code></p>
                  </td>

                  <td align="left" headers="r5c1-t4 r1c2-t4">
                    <p><code>'1234'</code></p>
                  </td>

                  <td align="left" headers="r5c1-t4 r1c3-t4">
                    <p><code>'123'</code></p>

                    <p><code>'12993'</code></p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div><a id="BNBVI"></a><a id="JEETT00736"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.8</span> <a id="sthref2072"></a>NULL Comparison Expressions</h3>

          <p>A <code>NULL</code> comparison expression tests whether a single-valued path expression or an input parameter has a <code>NULL</code> value. Usually, the <code>NULL</code> comparison expression is used to test whether a single-valued relationship has been set:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Team t
WHERE t.league IS NULL
</pre>

          <p>This query selects all teams where the league relationship is not set. Note that the following query is <span class="italic">not</span> equivalent:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Team t
WHERE t.league = NULL
</pre>

          <p>The comparison with <code>NULL</code> using the equals operator (<code>=</code>) always returns an unknown value, even if the relationship is not set. The second query will always return an empty result.</p>
        </div><a id="BNBVJ"></a><a id="JEETT00737"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.9</span> Empty Collection Comparison Expressions</h3>

          <p><a id="sthref2073"></a>The <code>IS [NOT] EMPTY</code> comparison expression tests whether a collection-valued path expression has no elements. In other words, it tests whether a collection-valued relationship has been set.</p>

          <p>If the collection-valued path expression is <code>NULL</code>, the empty collection comparison expression has a <code>NULL</code> value.</p>

          <p>Here is an example that finds all orders that do not have any line items:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT o
FROM CustomerOrder o
WHERE o.lineItems IS EMPTY
</pre>
        </div><a id="BNBVK"></a><a id="JEETT00738"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.10</span> <a id="sthref2074"></a><a id="sthref2075"></a><a id="sthref2076"></a>Collection Member Expressions</h3>

          <p>The <code>[NOT]</code> <code>MEMBER [OF]</code> collection member expression determines whether a value is a member of a collection. The value and the collection members must have the same type.</p>

          <p>If either the collection-valued or single-valued path expression is unknown, the collection member expression is unknown. If the collection-valued path expression designates an empty collection, the collection member expression is <code>FALSE</code>.</p>

          <p>The <code>OF</code> keyword is optional.</p>

          <p>The following example tests whether a line item is part of an order:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT o
FROM CustomerOrder o
WHERE :lineItem MEMBER OF o.lineItems
</pre>
        </div><a id="BNBVL"></a><a id="JEETT00739"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.11</span> <a id="sthref2077"></a>Subqueries</h3>

          <p>Subqueries may be used in the <code>WHERE</code> or <code>HAVING</code> clause of a query. Subqueries must be surrounded by parentheses.</p>

          <p>The following example finds all customers who have placed more than ten orders:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c
FROM Customer c
WHERE (SELECT COUNT(o) FROM c.orders o)&gt; 10
</pre>

          <p>Subqueries may contain <code>EXISTS</code>, <code>ALL</code>, and <code>ANY</code> expressions.</p>

          <ul>
            <li>
              <p><a id="sthref2078"></a><span class="bold">EXISTS expressions</span>: The <code>[NOT] EXISTS</code> expression is used with a subquery and is true only if the result of the subquery consists of one or more values; otherwise, it is false.</p>

              <p>The following example finds all employees whose spouses are also employees:</p>
              <pre class="oac_no_warn" xml:space="preserve">
SELECT DISTINCT emp
FROM Employee emp
WHERE EXISTS (
    SELECT spouseEmp
    FROM Employee spouseEmp
    WHERE spouseEmp = emp.spouse)
</pre>
            </li>

            <li>
              <p><a id="sthref2079"></a><a id="sthref2080"></a><span class="bold">ALL and ANY expressions</span>: The <code>ALL</code> expression is used with a subquery and is true if all the values returned by the subquery are true or if the subquery is empty.</p>

              <p>The <code>ANY</code> expression is used with a subquery and is true if some of the values returned by the subquery are true. An <code>ANY</code> expression is false if the subquery result is empty or if all the values returned are false. The <code>SOME</code> keyword is synonymous with <code>ANY</code>.</p>

              <p>The <code>ALL</code> and <code>ANY</code> expressions are used with the <code>=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;&gt;</code> comparison operators.</p>

              <p>The following example finds all employees whose salaries are higher than the salaries of the managers in the employee's department:</p>
              <pre class="oac_no_warn" xml:space="preserve">
SELECT emp
FROM Employee emp
WHERE emp.salary &gt; ALL (
    SELECT m.salary
    FROM Manager m
    WHERE m.department = emp.department)
</pre>
            </li>
          </ul>
        </div><a id="BNBVO"></a><a id="JEETT00740"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.12</span> <a id="sthref2081"></a><a id="sthref2082"></a>Functional Expressions</h3>

          <p>The query language includes several string, arithmetic, and date/time functions that may be used in the <code>SELECT</code>, <code>WHERE</code>, or <code>HAVING</code> clause of a query. The functions are listed in <a href="../Text/persistence-querylanguage.xhtml#BNBVP">Table 39-4</a>, <a href="../Text/persistence-querylanguage.xhtml#BNBVQ">Table 39-5</a>, and <a href="../Text/persistence-querylanguage.xhtml#GJJNL">Table 39-6</a>.</p>

          <p>In <a href="../Text/persistence-querylanguage.xhtml#BNBVP">Table 39-4</a>, the <code>start</code> and <code>length</code> arguments are of type <code>int</code> and designate positions in the <code>String</code> argument. The first position in a string is designated by 1.</p>

          <div class="tblhruleformal">
            <a id="sthref2083"></a><a id="BNBVP"></a>

            <p class="titleintable">Table 39-4 String Expressions</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists the syntax and return types of string expressions." title="String Expressions" width="100%">
              <col width="*" />
              <col width="29%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t5" valign="bottom">Function Syntax</th>

                  <th align="left" id="r1c2-t5" valign="bottom">Return Type</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r2c1-t5">
                    <p><code>CONCAT(String, String)</code></p>
                  </td>

                  <td align="left" headers="r2c1-t5 r1c2-t5">
                    <p><code>String</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r3c1-t5">
                    <p><code>LENGTH(String)</code></p>
                  </td>

                  <td align="left" headers="r3c1-t5 r1c2-t5">
                    <p><code>int</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r4c1-t5">
                    <p><code>LOCATE(String, String [, start])</code></p>
                  </td>

                  <td align="left" headers="r4c1-t5 r1c2-t5">
                    <p><code>int</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r5c1-t5">
                    <p><code>SUBSTRING(String, start, length)</code></p>
                  </td>

                  <td align="left" headers="r5c1-t5 r1c2-t5">
                    <p><code>String</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r6c1-t5">
                    <p><code>TRIM([[LEADING|TRAILING|BOTH] char) FROM] (String)</code></p>
                  </td>

                  <td align="left" headers="r6c1-t5 r1c2-t5">
                    <p><code>String</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r7c1-t5">
                    <p><code>LOWER(String)</code></p>
                  </td>

                  <td align="left" headers="r7c1-t5 r1c2-t5">
                    <p><code>String</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t5" id="r8c1-t5">
                    <p><code>UPPER(String)</code></p>
                  </td>

                  <td align="left" headers="r8c1-t5 r1c2-t5">
                    <p><code>String</code></p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <p><a id="sthref2084"></a>The <code>CONCAT</code> function concatenates two strings into one string.</p>

          <p><a id="sthref2085"></a>The <code>LENGTH</code> function returns the length of a string in characters as an integer.</p>

          <p><a id="sthref2086"></a>The <code>LOCATE</code> function returns the position of a given string within a string. This function returns the first position at which the string was found as an integer. The first argument is the string to be located. The second argument is the string to be searched. The optional third argument is an integer that represents the starting string position. By default, <code>LOCATE</code> starts at the beginning of the string. The starting position of a string is <code>1</code>. If the string cannot be located, <code>LOCATE</code> returns <code>0</code>.</p>

          <p><a id="sthref2087"></a>The <code>SUBSTRING</code> function returns a string that is a substring of the first argument based on the starting position and length.</p>

          <p><a id="sthref2088"></a>The <code>TRIM</code> function trims the specified character from the beginning and/or end of a string. If no character is specified, <code>TRIM</code> removes spaces or blanks from the string. If the optional <code>LEADING</code> specification is used, <code>TRIM</code> removes only the leading characters from the string. If the optional <code>TRAILING</code> specification is used, <code>TRIM</code> removes only the trailing characters from the string. The default is <code>BOTH</code>, which removes the leading and trailing characters from the string.</p>

          <p><a id="sthref2089"></a><a id="sthref2090"></a>The <code>LOWER</code> and <code>UPPER</code> functions convert a string to lowercase or uppercase, respectively.</p>

          <p>In <a href="../Text/persistence-querylanguage.xhtml#BNBVQ">Table 39-5</a>, the <code>number</code> argument can be an <code>int</code>, a <code>float</code>, or a <code>double</code>.</p>

          <div class="tblhruleformal">
            <a id="sthref2091"></a><a id="BNBVQ"></a>

            <p class="titleintable">Table 39-5 Arithmetic Expressions</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists the syntax and return types of arithmetic expressions." title="Arithmetic Expressions" width="100%">
              <col width="*" />
              <col width="38%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t6" valign="bottom">Function Syntax</th>

                  <th align="left" id="r1c2-t6" valign="bottom">Return Type</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t6" id="r2c1-t6">
                    <p><code>ABS(number)</code></p>
                  </td>

                  <td align="left" headers="r2c1-t6 r1c2-t6">
                    <p><code>int</code>, <code>float</code>, or <code>double</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t6" id="r3c1-t6">
                    <p><code>MOD(int, int)</code></p>
                  </td>

                  <td align="left" headers="r3c1-t6 r1c2-t6">
                    <p><code>int</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t6" id="r4c1-t6">
                    <p><code>SQRT(double)</code></p>
                  </td>

                  <td align="left" headers="r4c1-t6 r1c2-t6">
                    <p><code>double</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t6" id="r5c1-t6">
                    <p><code>SIZE(Collection)</code></p>
                  </td>

                  <td align="left" headers="r5c1-t6 r1c2-t6">
                    <p><code>int</code></p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <p><a id="sthref2092"></a>The <code>ABS</code> function takes a numeric expression and returns a number of the same type as the argument.</p>

          <p><a id="sthref2093"></a>The <code>MOD</code> function returns the remainder of the first argument divided by the second.</p>

          <p><a id="sthref2094"></a>The <code>SQRT</code> function returns the square root of a number.</p>

          <p><a id="sthref2095"></a>The <code>SIZE</code> function returns an integer of the number of elements in the given collection.</p>

          <p>In <a href="../Text/persistence-querylanguage.xhtml#GJJNL">Table 39-6</a>, the date/time functions return the date, time, or timestamp on the database server.</p>

          <div class="tblhruleformal">
            <a id="sthref2096"></a><a id="GJJNL"></a>

            <p class="titleintable">Table 39-6 Date/Time Expressions</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists the syntax and return types of date and time expressions." title="Date/Time Expressions" width="100%">
              <col width="*" />
              <col width="50%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t7" valign="bottom">Function Syntax</th>

                  <th align="left" id="r1c2-t7" valign="bottom">Return Type</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t7" id="r2c1-t7">
                    <p><code>CURRENT_DATE</code></p>
                  </td>

                  <td align="left" headers="r2c1-t7 r1c2-t7">
                    <p><code>java.sql.Date</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t7" id="r3c1-t7">
                    <p><code>CURRENT_TIME</code></p>
                  </td>

                  <td align="left" headers="r3c1-t7 r1c2-t7">
                    <p><code>java.sql.Time</code></p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t7" id="r4c1-t7">
                    <p><code>CURRENT_TIMESTAMP</code></p>
                  </td>

                  <td align="left" headers="r4c1-t7 r1c2-t7">
                    <p><code>java.sql.Timestamp</code></p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div><a id="GJJND"></a><a id="JEETT00741"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.13</span> <a id="sthref2097"></a>Case Expressions</h3>

          <p>Case expressions change based on a condition, similar to the <code>case</code> keyword of the Java programming language. The <code>CASE</code> keyword indicates the start of a case expression, and the expression is terminated by the <code>END</code> keyword. The <code>WHEN</code> and <code>THEN</code> keywords define individual conditions, and the <code>ELSE</code> keyword defines the default condition should none of the other conditions be satisfied.</p>

          <p>The following query selects the name of a person and a conditional string, depending on the subtype of the <code>Person</code> entity. If the subtype is <code>Student</code>, the string <code>kid</code> is returned. If the subtype is <code>Guardian</code> or <code>Staff</code>, the string <code>adult</code> is returned. If the entity is some other subtype of <code>Person</code>, the string <code>unknown</code> is returned:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT p.name
CASE TYPE(p)
    WHEN Student THEN 'kid'
    WHEN Guardian THEN 'adult'
    WHEN Staff THEN 'adult'
    ELSE 'unknown'
END
FROM Person p
</pre>

          <p>The following query sets a discount for various types of customers. Gold-level customers get a 20% discount, silver-level customers get a 15% discount, bronze-level customers get a 10% discount, and everyone else gets a 5% discount:</p>
          <pre class="oac_no_warn" xml:space="preserve">
UPDATE Customer c
SET c.discount = 
    CASE c.level
        WHEN 'Gold' THEN 20
        WHEN 'SILVER' THEN 15
        WHEN 'Bronze' THEN 10
        ELSE 5
    END
</pre>
        </div><a id="BNBVR"></a><a id="JEETT00742"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.14</span> <a id="sthref2098"></a>NULL Values</h3>

          <p><a id="sthref2099"></a>If the target of a reference is not in the persistent store, the target is <code>NULL</code>. For conditional expressions containing <code>NULL</code>, the query language uses the semantics defined by SQL92. Briefly, these semantics are as follows.</p>

          <ul>
            <li>
              <p>If a comparison or arithmetic operation has an unknown value, it yields a <code>NULL</code> value.</p>
            </li>

            <li>
              <p>Two <code>NULL</code> values are not equal. Comparing two <code>NULL</code> values yields an unknown value.</p>
            </li>

            <li>
              <p>The <code>IS NULL</code> test converts a <code>NULL</code> persistent field or a single-valued relationship field to <code>TRUE</code>. The <code>IS NOT NULL</code> test converts them to <code>FALSE</code>.</p>
            </li>

            <li>
              <p><a id="sthref2100"></a>Boolean operators and conditional tests use the three-valued logic defined by <a href="../Text/persistence-querylanguage.xhtml#BNBVS">Table 39-7</a> and <a href="../Text/persistence-querylanguage.xhtml#BNBVT">Table 39-8</a>. (In these tables, T stands for <code>TRUE</code>, F for <code>FALSE</code>, and U for unknown.)</p>
            </li>
          </ul>

          <div class="tblhruleformal">
            <a id="sthref2101"></a><a id="BNBVS"></a>

            <p class="titleintable">Table 39-7 AND Operator Logic</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table provides a truth table that shows AND operator logic." title="AND Operator Logic" width="100%">
              <col width="*" />
              <col width="20%" />
              <col width="20%" />
              <col width="20%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t8" valign="bottom">AND</th>

                  <th align="left" id="r1c2-t8" valign="bottom">T</th>

                  <th align="left" id="r1c3-t8" valign="bottom">F</th>

                  <th align="left" id="r1c4-t8" valign="bottom">U</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t8" id="r2c1-t8">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t8 r1c2-t8">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t8 r1c3-t8">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r2c1-t8 r1c4-t8">
                    <p>U</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t8" id="r3c1-t8">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t8 r1c2-t8">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t8 r1c3-t8">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t8 r1c4-t8">
                    <p>F</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t8" id="r4c1-t8">
                    <p>U</p>
                  </td>

                  <td align="left" headers="r4c1-t8 r1c2-t8">
                    <p>U</p>
                  </td>

                  <td align="left" headers="r4c1-t8 r1c3-t8">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r4c1-t8 r1c4-t8">
                    <p>U</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <div class="tblhruleformal">
            <a id="sthref2102"></a><a id="BNBVT"></a>

            <p class="titleintable">Table 39-8 OR Operator Logic</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table provides a truth table that shows OR operator logic." title="OR Operator Logic" width="100%">
              <col width="*" />
              <col width="20%" />
              <col width="20%" />
              <col width="20%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t9" valign="bottom">OR</th>

                  <th align="left" id="r1c2-t9" valign="bottom">T</th>

                  <th align="left" id="r1c3-t9" valign="bottom">F</th>

                  <th align="left" id="r1c4-t9" valign="bottom">U</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t9" id="r2c1-t9">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t9 r1c2-t9">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t9 r1c3-t9">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t9 r1c4-t9">
                    <p>T</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t9" id="r3c1-t9">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t9 r1c2-t9">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r3c1-t9 r1c3-t9">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t9 r1c4-t9">
                    <p>U</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t9" id="r4c1-t9">
                    <p>U</p>
                  </td>

                  <td align="left" headers="r4c1-t9 r1c2-t9">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r4c1-t9 r1c3-t9">
                    <p>U</p>
                  </td>

                  <td align="left" headers="r4c1-t9 r1c4-t9">
                    <p>U</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div><a id="BNBVU"></a><a id="JEETT00743"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.5.15</span> <a id="sthref2103"></a>Equality Semantics</h3>

          <p><a id="sthref2104"></a><a id="sthref2105"></a>In the query language, only values of the same type can be compared. However, this rule has one exception: Exact and approximate numeric values can be compared. In such a comparison, the required type conversion adheres to the rules of Java numeric promotion.</p>

          <p>The query language treats compared values as if they were Java types and not as if they represented types in the underlying data store. For example, a persistent field that could be either an integer or a <code>NULL</code> must be designated as an <code>Integer</code> object and not as an <code>int</code> primitive. This designation is required because a Java object can be <code>NULL</code>, but a primitive cannot.</p>

          <p><a id="sthref2106"></a>Two strings are equal only if they contain the same sequence of characters. Trailing blanks are significant; for example, the strings <code>'abc'</code> and <code>'abc '</code> are not equal.</p>

          <p><a id="sthref2107"></a><a id="sthref2108"></a><a id="sthref2109"></a><a id="sthref2110"></a><a id="sthref2111"></a>Two entities of the same abstract schema type are equal only if their primary keys have the same value. <a href="../Text/persistence-querylanguage.xhtml#BNBVV">Table 39-9</a> shows the operator logic of a negation, and <a href="../Text/persistence-querylanguage.xhtml#BNBVW">Table 39-10</a> shows the truth values of conditional tests.</p>

          <div class="tblhruleformal">
            <a id="sthref2112"></a><a id="BNBVV"></a>

            <p class="titleintable">Table 39-9 NOT Operator Logic</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table provides a truth table that shows NOT operator logic." title="NOT Operator Logic" width="100%">
              <col width="45%" />
              <col width="*" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t10" valign="bottom">NOT Value</th>

                  <th align="left" id="r1c2-t10" valign="bottom">Value</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t10" id="r2c1-t10">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t10 r1c2-t10">
                    <p>F</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t10" id="r3c1-t10">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t10 r1c2-t10">
                    <p>T</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t10" id="r4c1-t10">
                    <p>U</p>
                  </td>

                  <td align="left" headers="r4c1-t10 r1c2-t10">
                    <p>U</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <div class="tblhruleformal">
            <a id="sthref2113"></a><a id="BNBVW"></a>

            <p class="titleintable">Table 39-10 Conditional Test</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table shows truth values for conditional tests." title="Conditional Test" width="100%">
              <col width="*" />
              <col width="12%" />
              <col width="12%" />
              <col width="12%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t11" valign="bottom">Conditional Test</th>

                  <th align="left" id="r1c2-t11" valign="bottom">T</th>

                  <th align="left" id="r1c3-t11" valign="bottom">F</th>

                  <th align="left" id="r1c4-t11" valign="bottom">U</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t11" id="r2c1-t11">
                    <p>Expression <code>IS TRUE</code></p>
                  </td>

                  <td align="left" headers="r2c1-t11 r1c2-t11">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r2c1-t11 r1c3-t11">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r2c1-t11 r1c4-t11">
                    <p>F</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t11" id="r3c1-t11">
                    <p>Expression <code>IS FALSE</code></p>
                  </td>

                  <td align="left" headers="r3c1-t11 r1c2-t11">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r3c1-t11 r1c3-t11">
                    <p>T</p>
                  </td>

                  <td align="left" headers="r3c1-t11 r1c4-t11">
                    <p>F</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t11" id="r4c1-t11">
                    <p>Expression is unknown</p>
                  </td>

                  <td align="left" headers="r4c1-t11 r1c2-t11">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r4c1-t11 r1c3-t11">
                    <p>F</p>
                  </td>

                  <td align="left" headers="r4c1-t11 r1c4-t11">
                    <p>T</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>
        </div>
      </div><a id="BNBVX"></a><a id="JEETT01193"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_776"><span class="secnum">39.5.6</span> <a id="sthref2114"></a>SELECT Clause</h2>

        <p>The <code>SELECT</code> clause defines the types of the objects or values returned by the query.</p><a id="BNBVY"></a><a id="JEETT00744"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.6.1</span> Return Types</h3>

          <p><a id="sthref2115"></a>The return type of the <code>SELECT</code> clause is defined by the result types of the select expressions contained within it. If multiple expressions are used, the result of the query is an <code>Object[]</code>, and the elements in the array correspond to the order of the expressions in the <code>SELECT</code> clause and in type to the result types of each expression.</p>

          <p>A <code>SELECT</code> clause cannot specify a collection-valued expression. For example, the <code>SELECT</code> clause <code>p.teams</code> is invalid because <code>teams</code> is a collection. However, the clause in the following query is valid because <code>t</code> is a single element of the <code>teams</code> collection:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT t
FROM Player p, IN (p.teams) t
</pre>

          <p>The following query is an example of a query with multiple expressions in the <code>SELECT</code> clause:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT c.name, c.country.name
FROM customer c
WHERE c.lastname = 'Coss' AND c.firstname = 'Roxane'
</pre>

          <p>This query returns a list of <code>Object[]</code> elements; the first array element is a string denoting the customer name, and the second array element is a string denoting the name of the customer's country.</p>

          <p>The result of a query may be the result of an aggregate function, listed in <a href="../Text/persistence-querylanguage.xhtml#BNBWA">Table 39-11</a>.</p>

          <div class="tblhruleformal">
            <a id="sthref2116"></a><a id="BNBWA"></a>

            <p class="titleintable">Table 39-11 Aggregate Functions in Select Statements</p>

            <table border="1" cellpadding="3" cellspacing="0" class="HRuleFormal" dir="ltr" frame="hsides" rules="rows" summary="This table lists and describes the aggregate functions used in select statements and shows their return types." title="Aggregate Functions in Select Statements" width="100%">
              <col width="20%" />
              <col width="*" />
              <col width="37%" />

              <thead>
                <tr align="left" valign="top">
                  <th align="left" id="r1c1-t12" valign="bottom">Name</th>

                  <th align="left" id="r1c2-t12" valign="bottom">Return Type</th>

                  <th align="left" id="r1c3-t12" valign="bottom">Description</th>
                </tr>
              </thead>

              <tbody>
                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t12" id="r2c1-t12">
                    <p><a id="sthref2117"></a><code>AVG</code></p>
                  </td>

                  <td align="left" headers="r2c1-t12 r1c2-t12">
                    <p><code>Double</code></p>
                  </td>

                  <td align="left" headers="r2c1-t12 r1c3-t12">
                    <p>Returns the mean average of the fields</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t12" id="r3c1-t12">
                    <p><a id="sthref2118"></a><code>COUNT</code></p>
                  </td>

                  <td align="left" headers="r3c1-t12 r1c2-t12">
                    <p><code>Long</code></p>
                  </td>

                  <td align="left" headers="r3c1-t12 r1c3-t12">
                    <p>Returns the total number of results</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t12" id="r4c1-t12">
                    <p><a id="sthref2119"></a><code>MAX</code></p>
                  </td>

                  <td align="left" headers="r4c1-t12 r1c2-t12">
                    <p>The type of the field</p>
                  </td>

                  <td align="left" headers="r4c1-t12 r1c3-t12">
                    <p>Returns the highest value in the result set</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t12" id="r5c1-t12">
                    <p><a id="sthref2120"></a><code>MIN</code></p>
                  </td>

                  <td align="left" headers="r5c1-t12 r1c2-t12">
                    <p>The type of the field</p>
                  </td>

                  <td align="left" headers="r5c1-t12 r1c3-t12">
                    <p>Returns the lowest value in the result set</p>
                  </td>
                </tr>

                <tr align="left" valign="top">
                  <td align="left" headers="r1c1-t12" id="r6c1-t12">
                    <p><a id="sthref2121"></a><code>SUM</code></p>
                  </td>

                  <td align="left" headers="r6c1-t12 r1c2-t12">
                    <p><code>Long</code> (for integral fields)</p>

                    <p><code>Double</code> (for floating-point fields)</p>

                    <p><code>BigInteger</code> (for <code>BigInteger</code> fields)</p>

                    <p><code>BigDecimal</code> (for <code>BigDecimal</code> fields)</p>
                  </td>

                  <td align="left" headers="r6c1-t12 r1c3-t12">
                    <p>Returns the sum of all the values in the result set</p>
                  </td>
                </tr>
              </tbody>
            </table><br />
          </div>

          <p>For select method queries with an aggregate function (<code>AVG</code>, <code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, or <code>SUM</code>) in the <code>SELECT</code> clause, the following rules apply.</p>

          <ul>
            <li>
              <p>The <code>AVG</code>, <code>MAX</code>, <code>MIN</code>, and <code>SUM</code> functions return <code>null</code> if there are no values to which the function can be applied.</p>
            </li>

            <li>
              <p>The <code>COUNT</code> function returns 0 if there are no values to which the function can be applied.</p>
            </li>
          </ul>

          <p>The following example returns the average order quantity:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT AVG(o.quantity)
FROM CustomerOrder o
</pre>

          <p>The following example returns the total cost of the items ordered by Roxane Coss:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT SUM(l.price)
FROM CustomerOrder o JOIN o.lineItems l JOIN o.customer c
WHERE c.lastname = 'Coss' AND c.firstname = 'Roxane'
</pre>

          <p>The following example returns the total number of orders:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT COUNT(o)
FROM CustomerOrder o
</pre>

          <p>The following example returns the total number of items that have prices in Hal Incandenza's order:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT COUNT(l.price)
FROM CustomerOrder o JOIN o.lineItems l JOIN o.customer c
WHERE c.lastname = 'Incandenza' AND c.firstname = 'Hal'
</pre>
        </div><a id="BNBWB"></a><a id="JEETT00745"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.6.2</span> The DISTINCT Keyword</h3>

          <p>The <code>DISTINCT</code> keyword eliminates duplicate return values. If a query returns a <code>java.util.Collection</code>, which allows duplicates, you must specify the <code>DISTINCT</code> keyword to eliminate duplicates.</p>
        </div><a id="BNBWC"></a><a id="JEETT00746"></a>

        <div class="sect3">
          <h3 class="sect3 sigil_not_in_toc"><span class="secnum">39.5.6.3</span> <a id="sthref2122"></a>Constructor Expressions</h3>

          <p>Constructor expressions allow you to return Java instances that store a query result element instead of an <code>Object[]</code>.</p>

          <p>The following query creates a <code>CustomerDetail</code> instance per <code>Customer</code> matching the <code>WHERE</code> clause. A <code>CustomerDetail</code> stores the customer name and customer's country name. So the query returns a <code>List</code> of <code>CustomerDetail</code> instances:</p>
          <pre class="oac_no_warn" xml:space="preserve">
SELECT NEW com.example.CustomerDetail(c.name, c.country.name)
FROM customer c
WHERE c.lastname = 'Coss' AND c.firstname = 'Roxane'
</pre>
        </div>
      </div><a id="BNBWD"></a><a id="JEETT01194"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_777"><span class="secnum">39.5.7</span> <a id="sthref2123"></a>ORDER BY Clause</h2>

        <p>As its name suggests, the <code>ORDER BY</code> clause orders the values or objects returned by the query.</p>

        <p>If the <code>ORDER BY</code> clause contains multiple elements, the left-to-right sequence of the elements determines the high-to-low precedence.</p>

        <p><a id="sthref2124"></a><a id="sthref2125"></a>The <code>ASC</code> keyword specifies ascending order, the default, and the <code>DESC</code> keyword indicates descending order.</p>

        <p>When using the <code>ORDER BY</code> clause, the <code>SELECT</code> clause must return an orderable set of objects or values. You cannot order the values or objects for values or objects not returned by the <code>SELECT</code> clause. For example, the following query is valid because the <code>ORDER BY</code> clause uses the objects returned by the <code>SELECT</code> clause:</p>
        <pre class="oac_no_warn" xml:space="preserve">
SELECT o
FROM Customer c JOIN c.orders o JOIN c.address a
WHERE a.state = 'CA'
ORDER BY o.quantity, o.totalcost
</pre>

        <p>The following example is <span class="italic">not</span> valid, because the <code>ORDER BY</code> clause uses a value not returned by the <code>SELECT</code> clause:</p>
        <pre class="oac_no_warn" xml:space="preserve">
SELECT p.product_name
FROM CustomerOrder o, IN(o.lineItems) l JOIN o.customer c
WHERE c.lastname = 'Faehmel' AND c.firstname = 'Robert'
ORDER BY o.quantity
</pre>
      </div><a id="BNBWE"></a><a id="JEETT01195"></a>

      <div class="sect2">
        <h2 class="sect2" id="sigil_toc_id_778"><span class="secnum">39.5.8</span> <a id="sthref2126"></a><a id="sthref2127"></a>GROUP BY and HAVING Clauses</h2>

        <p>The <code>GROUP BY</code> clause allows you to group values according to a set of properties.</p>

        <p>The following query groups the customers by their country and returns the number of customers per country:</p>
        <pre class="oac_no_warn" xml:space="preserve">
SELECT c.country, COUNT(c)
FROM Customer c GROUP BY c.country
</pre>

        <p>The <code>HAVING</code> clause is used with the <code>GROUP BY</code> clause to further restrict the returned result of a query.</p>

        <p>The following query groups orders by the status of their customer and returns the customer status plus the average <code>totalPrice</code> for all orders where the corresponding customers have the same status. In addition, it considers only customers with status <code>1</code>, <code>2</code>, or <code>3</code>, so orders of other customers are not taken into account:</p>
        <pre class="oac_no_warn" xml:space="preserve">
SELECT c.status, AVG(o.totalPrice)
FROM CustomerOrder o JOIN o.customer c
GROUP BY c.status HAVING c.status IN (1, 2, 3)
</pre>
      </div>
    </div>
  </div>
</body>
</html>
